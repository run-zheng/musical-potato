{"meta":{"title":"ZhengRun's Blog","subtitle":"郑润的个人博客","description":"zheng run(郑润)的个人博客.","author":"zheng run","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"maven-shade-plugin介绍","slug":"maven-shade-plugin","date":"2019-11-06T19:19:39.000Z","updated":"2019-11-07T09:35:48.163Z","comments":true,"path":"2019/11/06/maven-shade-plugin/","link":"","permalink":"http://yoursite.com/2019/11/06/maven-shade-plugin/","excerpt":"","text":"[TOC] 一、 缘起编写java agent插件的时候，用到javassist修改字节码，插件用来记录调用链的，需要在方法的前后插入代码。突发奇想，用来看看javassist是怎么调用的，结果达不到预期效果，因为java agent中，javassist的代码已经加载过了，没插入记录调用链的代码，刚好看到guava中有介绍用maven-shade-plugin将guava repackage重命名包名，因此记录下。 二、maven-shade-plugin介绍maven-shade-plugin是一个maven打包插件，提供的功能比较丰富，使用也简单易懂。 1、简单打包简单打包只需要增加execution, 指定执行package的phase，为这个phase绑定global shade就ok12345678910111213&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 2、打包可运行的jar增加configuration, 添加ManifestResourceTransformer的transformer，指定main入口的mainClass 1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt; &lt;mainClass&gt;org.demo.App&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 3、打包第三方jar包和排除第三方jar包configuration下增加artifactSet，includes添加需要增加的第三方maven依赖，excludes排除不需要打包进来的第三方依赖，include和exclude的标签里格式是maven的坐标和类型等， 格式：groupId:artifactId[[:type]:classifier],type可以是jar、war、pom,这里需要注意的是scope是test、provided的话，是无法include进来的，compile(默认)、runtime会被包含进来。1234567891011&lt;configuration&gt; &lt;artifactSet&gt; &lt;includes&gt; &lt;include&gt;*:*&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;org.projectlombok:lombok&lt;/exclude&gt; &lt;/excludes&gt; &lt;/artifactSet&gt; ...&lt;/configuration&gt; 也可以过滤第三方包中，指定那些文件打包进来，那些不打包。configuration下增加filters, filter说明过滤的条件和信息,include和exclude注意是文件路径，不是包路径。配置的每个filter,如果只配置了include，其他都会被exclude1234567891011121314151617181920&lt;configuration&gt; &lt;filters&gt; &lt;filter&gt; &lt;artifact&gt;javax.servlet.jsp:jsp-api&lt;/artifact&gt; &lt;includes&gt; &lt;include&gt;javax/servlet/jsp/**&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;javax/servlet/jsp/tagext/**&lt;/exclude&gt; &lt;/excludes&gt; &lt;/filter&gt; &lt;filter&gt; &lt;artifact&gt;*:*&lt;/artifact&gt; &lt;excludes&gt; &lt;exclude&gt;META-INF/NOTICE.txt&lt;/exclude&gt; &lt;/excludes&gt; &lt;/filter&gt; &lt;/filters&gt; ... &lt;/configuration&gt; 4、第三方包的包路径重命名可以通过relocations，将依赖的第三方包打包到jar包中，并且重命名类的包名，可以达到隔离第三方包、解决包冲突等功能。如果有不需要导入的，可以用exclude排除掉。123456789101112131415161718&lt;configuration&gt; &lt;artifactSet&gt; &lt;includes&gt; &lt;include&gt;org.javassist:javassist&lt;/include&gt; &lt;/includes&gt; &lt;/artifactSet&gt; &lt;relocations&gt; &lt;relocation&gt; &lt;pattern&gt;javassist&lt;/pattern&gt; &lt;shadedPattern&gt;org.demo.javassist&lt;/shadedPattern&gt; &lt;!--&lt;excludes&gt; &lt;exclude&gt;javassist.util.HotSwapAgent&lt;/exclude&gt; &lt;/excludes&gt;--&gt; &lt;/relocation&gt; &lt;/relocations&gt; ...&lt;/configuration&gt; 5、其他配置12345678910111213&lt;!--打包的jar文件名，如果配置shadedArtifactAttached=true,该jar包不包含依赖的第三方包--&gt;&lt;finalName&gt;$&#123;project.name&#125;-$&#123;project.version&#125;&lt;/finalName&gt;&lt;!-- true: 默认fasle, 最小化打包，去掉未用到的第三方包中的类,危险--&gt;&lt;minimizeJar&gt;false&lt;/minimizeJar&gt;&lt;!--true: 默认true, 如果第三方包已经被打到jar中，依赖的jar的&lt;dependencies&gt;将会从jar包中的maven pom中删除--&gt;&lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;&lt;!--true: 默认fasle, 打包的时候生成source jar,打包进去的第三方包也会把第三方包的sourc也打到source jar中--&gt;&lt;createSourcesJar&gt;false&lt;/createSourcesJar&gt;&lt;!--生成classifier，配置finalName后生成的jar包名格式是$&#123;project.name&#125;-$&#123;project.version&#125;-$&#123;classifier&#125;.jar--&gt;&lt;!--默认会生成一个Jar包和一个以 “-shaded”为结尾的uber-jar包，可以通过配置来指定finalName打出来的的后缀名--&gt;&lt;shadedArtifactAttached&gt;true&lt;/shadedArtifactAttached&gt;&lt;shadedClassifierName&gt;suffix&lt;/shadedClassifierName&gt; 三、maven-shade-plugin实战把官网的例子和网上一些文章的例子试验了一下。其实，主要用到的应该是基本打包功能，jar包命名，ManifestResourceTransformer，这些功能其他打包插件也可以做得到。relocation功能比较使用，引入第三方包有特殊需求的时候，比如隔离和避免版本冲突，可以用该功能解决。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.demo&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;maven-shade-plugin-demo&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--scope=test,不会打包到jar中 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--scope=provided,不会打包到jar中 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.24.1-GA&lt;/version&gt; &lt;/dependency&gt; &lt;!--第三方包依赖的其他包也会一并打到jar中 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;configuration&gt; &lt;!--打包的jar文件名，如果配置shadedArtifactAttached=true,该jar包不包含依赖的第三方包--&gt; &lt;finalName&gt;$&#123;project.name&#125;-$&#123;project.version&#125;&lt;/finalName&gt; &lt;!-- true: 默认fasle, 最小化打包，去掉未用到的第三方包中的类,危险--&gt; &lt;minimizeJar&gt;false&lt;/minimizeJar&gt; &lt;!--true: 默认true, 如果第三方包已经被打到jar中，依赖的jar的&lt;dependencies&gt;将会从jar包中的maven pom中删除--&gt; &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt; &lt;!--true: 默认fasle, 打包的时候生成source jar,打包进去的第三方包也会把第三方包的sourc也打到source jar中--&gt; &lt;createSourcesJar&gt;false&lt;/createSourcesJar&gt; &lt;!--生成classifier，配置finalName后生成的jar包名格式是$&#123;project.name&#125;-$&#123;project.version&#125;-$&#123;classifier&#125;.jar--&gt; &lt;!--默认会生成一个Jar包和一个以 “-shaded”为结尾的uber-jar包，可以通过配置来指定finalName打出来的的后缀名--&gt; &lt;shadedArtifactAttached&gt;true&lt;/shadedArtifactAttached&gt; &lt;shadedClassifierName&gt;suffix&lt;/shadedClassifierName&gt; &lt;filters&gt; &lt;!--更精细的指定那些文件要include那些要exclude--&gt; &lt;filter&gt; &lt;artifact&gt;javax.servlet.jsp:jsp-api&lt;/artifact&gt; &lt;includes&gt; &lt;include&gt;javax/servlet/jsp/**&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;javax/servlet/jsp/tagext/**&lt;/exclude&gt; &lt;/excludes&gt; &lt;/filter&gt; &lt;filter&gt; &lt;artifact&gt;*:*&lt;/artifact&gt; &lt;!--问题1：Invalid signature file digest for Manifest main attributes 原因：有些jar包生成时，会 使用jarsigner生成文件签名（完成性校验），分为两个文件存放在META-INF目录下： a signature file, with a .SF extension； a signature block file, with a .DSA, .RSA, or .EC extension；--&gt; &lt;excludes&gt; &lt;exclude&gt;META-INF/NOTICE.txt&lt;/exclude&gt; &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt; &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt; &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt; &lt;/excludes&gt; &lt;/filter&gt; &lt;/filters&gt; &lt;!--打包第三方包--&gt; &lt;artifactSet&gt; &lt;includes&gt; &lt;include&gt;*:*&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;org.projectlombok:lombok&lt;/exclude&gt; &lt;/excludes&gt; &lt;/artifactSet&gt; &lt;!--重新命名依赖的第三方包的类包名--&gt; &lt;relocations&gt; &lt;relocation&gt; &lt;pattern&gt;javassist&lt;/pattern&gt; &lt;shadedPattern&gt;org.demo.javassist&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;/relocations&gt; &lt;transformers&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt; &lt;!--启动类--&gt; &lt;mainClass&gt;org.demo.App&lt;/mainClass&gt; &lt;!--MANIFEST.MF文件的明细描述--&gt; &lt;manifestEntries&gt; &lt;Premain-Class&gt;org.demo.agent.Agent&lt;/Premain-Class&gt; &lt;Agent-Class&gt;org.demo.agent.Agent&lt;/Agent-Class&gt; &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt; &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt; &lt;Can-Set-Native-Method-Prefix&gt;true&lt;/Can-Set-Native-Method-Prefix&gt; &lt;/manifestEntries&gt; &lt;/transformer&gt; &lt;!--spi实现，如果多个包下存在相同接口的实现，可以用ServicesResourceTransformer合并--&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"/&gt; &lt;!--多个包下存在相同的资源名，内容需要合并，可以通过AppendingTransformer进行合并--&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.AppendingTransformer\"&gt; &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt; &lt;/transformer&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.AppendingTransformer\"&gt; &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt; &lt;/transformer&gt; &lt;!--xml文件的合并不是简单的append,需要特殊处理，避免破坏结构--&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.XmlAppendingTransformer\"&gt; &lt;resource&gt;META-INF/magic.xml&lt;/resource&gt; &lt;!-- Add this to enable loading of DTDs &lt;ignoreDtd&gt;false&lt;/ignoreDtd&gt; --&gt; &lt;/transformer&gt; &lt;!--国际化多语言的文件合并也需要特殊处理--&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ResourceBundleAppendingTransformer\"&gt; &lt;!-- the base name of the resource bundle, a fully qualified class name --&gt; &lt;basename&gt;path/to/Messages&lt;/basename&gt; &lt;/transformer&gt; &lt;!--不需要合并的资源文件的列表--&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.DontIncludeResourceTransformer\"&gt; &lt;resources&gt; &lt;resource&gt;.txt&lt;/resource&gt; &lt;resource&gt;READ.me&lt;/resource&gt; &lt;/resources&gt; &lt;/transformer&gt; &lt;!--可以把README.txt从resource打包的时候，放到META-INF/README... 试验没成功！！！--&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.IncludeResourceTransformer\"&gt; &lt;resource&gt;META-INF/README&lt;/resource&gt; &lt;file&gt;ReadMe.file&lt;/file&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","categories":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/categories/maven/"}],"tags":[{"name":"maven-shade-plugin","slug":"maven-shade-plugin","permalink":"http://yoursite.com/tags/maven-shade-plugin/"}],"keywords":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/categories/maven/"}]},{"title":"Java Agent","slug":"java-agent","date":"2019-11-02T17:27:46.000Z","updated":"2019-11-06T11:17:07.623Z","comments":true,"path":"2019/11/02/java-agent/","link":"","permalink":"http://yoursite.com/2019/11/02/java-agent/","excerpt":"","text":"[TOC] 一、Java Agent是什么 ？Java Agent是什么，换句话说在那些地方能看到它的身影呢？ 1、热部署； JRebel一个实现快速热部署、节省大量重启时间，提高开发效率的插件，java应用启动时，启动参数设置-javaagent:jrebel路径/jrebel.jar spring-loaded一个JRebel的开源实现，VM启动参数设置 -javaagent:springloaded路径/springloaded.jar -noverify 2、APMAPM缩写是 Application Performance Management &amp; Monitoring，应用程序的性能服务管理和监控APM基本是参考Google的Dapper(大规模分布式跟踪系统)的体系来做的，主要对分布式系统的前后端处理、服务端调用的性能消耗进行跟踪。 skywalking开源的APM系统， Java端的数据收集探针使用agent方式， 启动参数也要设置-javaagent:skywalking的agent路径/skywalking-agent.jar pinpoint另外一款开源的APM系统，通用采用agent探针， 启动参数-javaagent:pinpoint的agent路径/pinpoint-bootstrap.jar 3、线上诊断工具 arthas阿里的开源的Java诊断工具，采用命令行模式交互， java -jar arthas-boot.jar后，选择进程pid，attach到对应的进程，加载agent包 Btrace另外一款诊断工具,提供按断可靠的动态跟踪分析功能，./bin/btrace -cp , attach到对应的java进程 二、一个Java Agent Demo实例看起来功能非常强大，但是怎么Java Agent长啥样，实现一个agent有那些需要基本的套路，开发了后怎么用。 实现一个agent主要有两个注意点： 1、编写一个类，提供premain方法； 2、编写META-INF/MANIFEST.MF文件，指定Premain-Class成1编写的类 1、Premain-Class类Premain-Class类必须提供premain静态方法， premain方法有两种形式： a、public static void premain(String args, Instrumentation inst) b、public static void premain(String args) 如果同时提供以上两种，带Instrumentation参数的优先级更高，无Instrumentation的不会被调用。 args是随-javaagent:agent路径/java-agent.jar=args传入的args字符串，与main方法不同的是args只是一个字符串，不是字符串数组。 12345678910111213141516171819package org.demo.java.agent;import java.lang.instrument.Instrumentation;public class Agent &#123; public static void premain(String args, Instrumentation inst)&#123; System.out.println(agent); System.out.println(agent + args); System.out.println(\"isRetransformClassesSupported: \" + inst.isRetransformClassesSupported()); System.out.println(\"isRedefineClassesSupported: \" + inst.isRedefineClassesSupported()); System.out.println(\"isNativeMethodPrefixSupported: \" + inst.isNativeMethodPrefixSupported()); System.out.println(agent + Agent.class.getClassLoader().getClass().getName()); &#125; public static void premain(String args)&#123; System.out.println(agent); System.out.println(agent + args); &#125;&#125; 2、MAINIFEST.MF文件MANIFEST.MF文件用来描述jar包的信息，存放在jar包的META-INFO目录下。java agent的jar包，需要用到该文件，用来描述agent运行时，程序的入口。Premain-Class就是用来指定入口类的配置项。 12Manifest-Version: 1.0Premain-Class: agent 注意MANIFEST.MF最后有一个空行。 MANIFEST.MF可以使用MAVEN插件，在package的时候，一起生成。123456789101112131415161718192021222324&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;configuration&gt; &lt;!--一起打包依赖的jar--&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;!--生成MANIFEST.MF文件到jar包的META-INF--&gt; &lt;archive&gt; &lt;manifestEntries&gt; &lt;Premain-Class&gt;org.demo.java.agent.Agent&lt;/Premain-Class&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 三、怎么用agent使用agent，只需要在启动参数增加-javaagent:agent路径/agent.jar=args，就可以使用agent。 创建main方法的类：123456789package org.demo;public class App &#123; public static void main( String[] args ) &#123; System.out.println( \"Hello World!\" ); &#125;&#125; 执行App：123456789&gt;java -javaagent:agent的路径/java-agent-jar-with-dependencies.jar=hello org/demo/App================================Java Agent premain instrument======================Agent args: helloisRetransformClassesSupported: falseisRedefineClassesSupported: falseisNativeMethodPrefixSupported: falsegetAllLoadedClasses:Agent's ClassLoader: sun.misc.Launcher$AppClassLoaderHello World! 如果多次设置javaagent会怎样呢？ 1234567891011121314151617&gt;java -javaagent:agent的路径/java-agent-jar-with-dependencies.jar=hello -javaagent:agent的路径/java-agent-jar-with-dependencies.jar=world org/demo/App================================Java Agent premain instrument======================Agent args: helloisRetransformClassesSupported: falseisRedefineClassesSupported: falseisNativeMethodPrefixSupported: falsegetAllLoadedClasses:Agent's ClassLoader: sun.misc.Launcher$AppClassLoader================================Java Agent premain instrument======================Agent args: worldisRetransformClassesSupported: falseisRedefineClassesSupported: falseisNativeMethodPrefixSupported: falsegetAllLoadedClasses:Agent's ClassLoader: sun.misc.Launcher$AppClassLoaderHello World! 执行结果是设置多少次，就执行多少次。 四、 Instrumentation从上面的例子好像agent没啥卵用，除了输出点信息之外。但是我们注意到了两个参数的premain方法，有一个java.lang.instrument.Instrumentation。 我们来看看Instrumentation是个什么东西。 1、Instrumentation介紹类注释上说明了Instrumentation的目的：主要是提供开发工具代码所需的服务，用来将字节码注入到具体的方法，实现数据收集等功能，这类工具一般不更改原程序的行为，只是添加一些附加的功能。比如监控代理、探测器、覆盖率分析器和事件记录器等。 也就是主要用来开发工具的，当然改变程序的行为也是可以做到的，要看使用场景，是生产上的使用，还是开发测试的辅助工具。 java agent机制，提供了启动时一个加载java编写的插桩服务的入口，Instrumentation提供注入修改class对象字节码能力的钩子入口。这个钩子是通过一下两个方法实现钩子注入： a、void addTransformer(ClassFileTransformer transformer, boolean canRetransform); b、void addTransformer(ClassFileTransformer transformer); 注入的钩子会在某个类的字节码文件读取之后，类定义之前被调用, 我们只需要实现ClassFileTransformer的transform方法，在该方法中实现修改字节码，就能达到注入字节码的目的：123456byte[] transform( ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException 2、Instrumentation示例现在我们有个需求，要记录某些方法的执行时间，具体方法运行前确定。如果用AOP的方式，每次运行需要更改下AOP配置，是不是可以用java agent实现呢？从上面我们了解到的agent机制和instrumentation，思路可以整理下：具体的方法和类，可以通过agent的args传入，然后在transform的时候修改对应的类方法，注入记录时间的字节码。 修改premain方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void premain(String args, Instrumentation inst)&#123; System.out.println(\"================================Java Agent premain instrument======================\"); System.out.println(\"Agent args: \" + args); String[] classMethods = args.split(\";\"); final Map&lt;String, Set&lt;String&gt;&gt; classMethodMap = new HashMap&lt;String, Set&lt;String&gt; &gt; (); for (String classMethodList: classMethods) &#123; int indexOfClass = classMethodList.indexOf(\":\"); String className = classMethodList.substring(0, indexOfClass); String[] methods = classMethodList.substring(indexOfClass+1).split(\":\"); Set&lt;String&gt; methodSet = new HashSet&lt;&gt;(); for (String methodName: methods) &#123; methodSet.add(methodName); &#125; classMethodMap.put(className, methodSet); &#125; inst.addTransformer(new ClassFileTransformer() &#123; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; String packageClass = className.replaceAll(\"/\", \".\"); if(classMethodMap.containsKey(packageClass))&#123; CtClass ctClass = null; Set&lt;String&gt; methodSet = classMethodMap.get(packageClass); try &#123; ctClass = ClassPool.getDefault().makeClass(new ByteArrayInputStream(classfileBuffer)); if(!ctClass.isInterface())&#123; CtBehavior[] declaredBehaviors = ctClass.getDeclaredBehaviors(); for (CtBehavior behavior: declaredBehaviors) &#123; if(methodSet.contains(behavior.getName()))&#123; System.out.println(\"Inject byte code class: \"+ packageClass + \" method: \" + behavior.getName()); behavior.addLocalVariable(\"start\", CtClass.longType); behavior.insertBefore(\"start = System.currentTimeMillis();\"); behavior.insertAfter(\"System.out.println(\\\"Method cost by agent...method: \"+ behavior.getName() + \" cost: \\\" + (System.currentTimeMillis() - start ));\"); &#125; &#125; &#125; return ctClass.toBytecode(); &#125;catch(Exception ex)&#123; ex.printStackTrace(); &#125;finally&#123; if(ctClass != null)&#123; ctClass.detach(); &#125; &#125; &#125; return classfileBuffer; &#125; &#125;); &#125; 这里需要引入字节码修改的库，用的是javassist：12345&lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.24.1-GA&lt;/version&gt;&lt;/dependency&gt; 测试的App中增加一个方法longOperation：12345678910111213141516171819package org.demo;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class App &#123; public static void main( String[] args ) throws ClassNotFoundException, InterruptedException &#123; System.out.println( \"Hello World!\" ); log.info(\"Start long operation...\"); longOperation(); log.info(\"End of long operation...\"); &#125; public static void longOperation() throws InterruptedException &#123; Thread.sleep(1000); &#125;&#125; 然后更改启动参数：12345678&gt;java -javaagent:agent的路径/java-agent-instrument-jar-with-dependencies.jar=org.demo.App:longOperation org/demo/App================================Java Agent premain instrument======================Agent args: org.demo.App:longOperation:longOperation2Inject byte code class: org.demo.App method: longOperationHello World!20:26:40.519 [main] INFO org.demo.App - Start long operation...Method cost by agent...method: longOperation cost: 100620:26:41.533 [main] INFO org.demo.App - End of long operation... ok, 一个简单的agent就实现完毕了。 五、总结总的来说，实现一个agent并使用该agent还是挺简单的，只需要完成以下几步就可以搞定： 1、实现一个提供premain方法的类 2、在MANIFEST.MF文件中，指定premain方法所在的入口类 3、在premain方法中，将ClassFileTransformer的实现类，通过Instrumentation的addTransformer方法，设置类文件加载的回调钩子 4、打包agent成jar包 5、在目标应用启动时，指定-javaagent:agent的jar包路径=args 总的看来，机制简单，所以重点的内容还是在字节码修改，以便实现所需要的功能。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Java Agent","slug":"Java-Agent","permalink":"http://yoursite.com/tags/Java-Agent/"},{"name":"Instrument","slug":"Instrument","permalink":"http://yoursite.com/tags/Instrument/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"Hello World!——内嵌Jetty支持Servlet","slug":"hello-world-embedding-jetty-servlet","date":"2018-12-10T23:38:56.000Z","updated":"2019-10-17T02:09:56.910Z","comments":true,"path":"2018/12/10/hello-world-embedding-jetty-servlet/","link":"","permalink":"http://yoursite.com/2018/12/10/hello-world-embedding-jetty-servlet/","excerpt":"","text":"Hello World!——内嵌Jetty支持Servlet一、引入依赖包内嵌Jetty支持servlet、jsp, jsp支持jstl和el表达式，除了需要引入jetty-webapp之外，还需要引入apache-jsp和apache-jstl， jsp也是编译成servlet。 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;version&gt;9.4.14.v20181114&lt;/version&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;version&gt;9.4.14.v20181114&lt;/version&gt; &lt;artifactId&gt;apache-jsp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;version&gt;9.4.14.v20181114&lt;/version&gt; &lt;artifactId&gt;apache-jstl&lt;/artifactId&gt;&lt;/dependency&gt; 二、配置支持servlet, jsp, jstl, el表达式1、支持servlet内嵌jetty支持servlet，只需要引入WebAppContext作为handler就可以支持 12345// 用WebAppContext可以支持servletWebAppContext webApp = new WebAppContext();webApp.setContextPath(\"/\");webApp.setResourceBase(\"./src/main/webapp\"); 2、支持jsp但是, 要支持jsp还需要配置两个Configuration 1234// 支持JSP必须增加以下配置Configuration.ClassList classlist = Configuration.ClassList.setServerDefault(server);classlist.addBefore(\"org.eclipse.jetty.webapp.JettyWebXmlConfiguration\", \"org.eclipse.jetty.annotations.AnnotationConfiguration\"); 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=$Encode\"&gt; &lt;title&gt;show page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello world&lt;/h1&gt; &lt;% out.println(\"&lt;h2&gt;Hello JSP&lt;/h2&gt;\"); %&gt;&lt;/body&gt;&lt;/html&gt; 可以正常输出Hello World和Hello JSP。 3、支持jstl和el表达式如果在jsp中需要用到jstl和el表达式， 还需要配置容器引入的包格式： 1234//支持jstl和其他tag必须设置以下配置webApp.setAttribute( \"org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern\", \".*/[^/]*servlet-api-[^/]*\\\\.jar$|.*/javax.servlet.jsp.jstl-.*\\\\.jar$|.*/[^/]*taglibs.*\\\\.jar$\" ); jsp文件头中还需要特殊处理下， 增加配指令，否则会忽略el表达式： 1&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\" isELIgnored=\"false\" %&gt; 12345&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;c:forEach var=\"i\" begin=\"1\" end=\"10\" step=\"1\"&gt; &lt;c:out value=\"$&#123;i&#125;\" /&gt; &lt;br /&gt;&lt;/c:forEach&gt; &lt;%@ … %&gt; 是指令 &lt;% … %&gt; 是jsp脚本 &lt;c:… /&gt; 是jstl标签 ${…} 是el表达式 三、增加servlet、web.xml和index.jsp具体示例代码如下： 1、内嵌Jetty的启动类12345678910111213141516171819202122232425262728293031323334import org.eclipse.jetty.server.Server;import org.eclipse.jetty.webapp.Configuration;import org.eclipse.jetty.webapp.WebAppContext;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class JettyWebAppApplication &#123; public static void main(String[] args) &#123; Server server = new Server(8080); // 支持JSP必须增加以下配置 Configuration.ClassList classlist = Configuration.ClassList.setServerDefault(server); classlist.addBefore(\"org.eclipse.jetty.webapp.JettyWebXmlConfiguration\", \"org.eclipse.jetty.annotations.AnnotationConfiguration\"); // 用WebAppContext可以支持servlet WebAppContext webApp = new WebAppContext(); webApp.setContextPath(\"/\"); webApp.setResourceBase(\"./src/main/webapp\"); // 支持jstl和其他tag必须设置以下配置 webApp.setAttribute(\"org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern\", \".*/[^/]*servlet-api-[^/]*\\\\.jar$|.*/javax.servlet.jsp.jstl-.*\\\\.jar$|.*/[^/]*taglibs.*\\\\.jar$\"); server.setHandler(webApp); try &#123; server.start(); server.dumpStdErr(); server.join(); &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; &#125;&#125; 2、Servlet的demo类1234567891011121314151617181920212223import java.io.IOException;import javax.servlet.GenericServlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import com.alibaba.fastjson.JSON;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class HelloWorldServletDemo extends GenericServlet &#123; private static final long serialVersionUID = -1522387682150936960L; @Override public void init() throws ServletException &#123; super.init(); &#125; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; log.info(\"remote: &#123;&#125; params: &#123;&#125; \", req.getRemoteAddr(), JSON.toJSONString(req.getParameterMap())); res.getWriter().write(\"&lt;h1&gt;Hello World Servlet&lt;/h1&gt;\"); &#125;&#125; 3、web.xml配置1234567891011121314151617181920212223242526&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.5//EN\" \"http://java.sun.com/dtd/web-app_2_5.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;org.demo.hello.world.jetty.servlet.HelloWorldServletDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- The mapping for the default servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4、jsp页面1234567891011121314151617181920&lt;!-- 在jar包都有的前提下EL表达式原样输出，不被解析 原因是 page指令中确少 isELIgnored=\"false\" servlet3.0默认关闭了el表达式的解析 --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\" isELIgnored=\"false\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=$Encode\"&gt; &lt;title&gt;show page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello world&lt;/h1&gt; &lt;% out.println(\"&lt;h2&gt;Hello JSP&lt;/h2&gt;\"); %&gt; &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;c:forEach var=\"i\" begin=\"1\" end=\"10\" step=\"1\"&gt; &lt;c:out value=\"$&#123;i&#125;\" /&gt; &lt;br /&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 四、运行效果运行效果如图","categories":[{"name":"Hello World系列","slug":"Hello-World系列","permalink":"http://yoursite.com/categories/Hello-World系列/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://yoursite.com/tags/Hello-World/"},{"name":"Jetty","slug":"Jetty","permalink":"http://yoursite.com/tags/Jetty/"},{"name":"内嵌Jetty","slug":"内嵌Jetty","permalink":"http://yoursite.com/tags/内嵌Jetty/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}],"keywords":[{"name":"Hello World系列","slug":"Hello-World系列","permalink":"http://yoursite.com/categories/Hello-World系列/"}]},{"title":"Hello World！——内嵌Jetty","slug":"hello-world-embedding-jetty","date":"2018-11-27T00:02:53.000Z","updated":"2019-10-17T02:09:56.913Z","comments":true,"path":"2018/11/27/hello-world-embedding-jetty/","link":"","permalink":"http://yoursite.com/2018/11/27/hello-world-embedding-jetty/","excerpt":"","text":"Hello World！——内嵌Jetty[TOC] Jetty是一个开源的轻量级Servlet容器，提供JSP和servlet运行环境。Jetty是纯Java编写的，可以直接使用JAR包方式启动，使用简单，架构也简单。 Jetty从设计之初就考虑作为组件提供，口号是”Don’t deploy your application in Jetty, deploy Jetty in your application!”(不在Jetty中部署你的应用，在你的应用中部署Jetty)。 Jetty的组件划分比较清晰， Jetty源码挂在github上,有兴趣的可以下下来看看。 一、Jetty提供的功能Jetty托管在Eclipse基金会。Jetty Web Server可以作为Http服务器和Servlet容器使用， 提供静态和动态页面服务，可以独立部署也可以嵌入式使用。 Jetty项目中，组合各组件可以提供以下功能： 异步Http服务器(Asynchronous HTTP Server) 标准Servelt容器(Standards based Servlet Container) websocket服务器(websocket server) Http/2服务器(http/2 server) 异步客户端(Asynchronous Client (http/1.1, http/2, websocket)) 提供OSGI,JNDI,JMX,JASPI,AJP支持(OSGI, JNDI, JMX, JASPI, AJP support) 二、引入Jetty在应用中内嵌Jetty通过maven的方式引入Jetty的jar包。12345 &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;version&gt;9.4.14.v20181114&lt;/version&gt; &lt;artifactId&gt;jetty-server&lt;/artifactId&gt;&lt;/dependency&gt; jetty-server的jar包依赖关系如下, Jar包依赖非常简单： 三、Hello world实例代码演示内嵌Jetty，只需要创建Server，指定端口(8080)就可以将Jetty内嵌run起来，但是因为没有处理器，默认的404页面： 最简单的是继承AbstractHandler实现一个Handler，处理请求和响应数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.eclipse.jetty.server.Request;import org.eclipse.jetty.server.Server;import org.eclipse.jetty.server.handler.AbstractHandler;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class JettyHelloWorldDemo &#123; @Slf4j public static class Handler extends AbstractHandler &#123; @Override public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; log.info(\"Handler request start: &#123;&#125;\", request.getRequestURL()); //设置类型，指定编码utf8 response.setContentType(\"text/html; charset=utf-8\"); //设置响应状态吗 response.setStatus(HttpServletResponse.SC_OK); //写响应数据 response.getWriter().write(\"&lt;h1&gt;Hello world!&lt;/h1&gt;\"); //标记请求已处理，handle链 baseRequest.setHandled(true); log.info(\"Handler request end\"); &#125; &#125; public static void main(String[] args) &#123; //创建服务器 Server server = new Server(8080); try &#123; //设置handler server.setHandler(new Handler()); //启动服务器 server.start(); //阻塞Jetty server的线程池，直到线程池停止 server.join(); &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; &#125;&#125;","categories":[{"name":"Hello World系列","slug":"Hello-World系列","permalink":"http://yoursite.com/categories/Hello-World系列/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://yoursite.com/tags/Hello-World/"},{"name":"Jetty","slug":"Jetty","permalink":"http://yoursite.com/tags/Jetty/"},{"name":"内嵌Jetty","slug":"内嵌Jetty","permalink":"http://yoursite.com/tags/内嵌Jetty/"}],"keywords":[{"name":"Hello World系列","slug":"Hello-World系列","permalink":"http://yoursite.com/categories/Hello-World系列/"}]},{"title":"Java多线程的实现方式","slug":"java-thread-create","date":"2018-11-21T23:04:56.000Z","updated":"2019-10-17T02:09:56.918Z","comments":true,"path":"2018/11/21/java-thread-create/","link":"","permalink":"http://yoursite.com/2018/11/21/java-thread-create/","excerpt":"","text":"Java中实现多线程的方式一、继承Thread类继承Thread类，重写run方法，调用Thread的start()方法启动线程： 1234567891011121314151617/** * 实现线程方式：1、继承Thread类 */@Slf4jpublic static class ThreadTarget extends Thread &#123; @Override public void run() &#123; while (true) &#123; log.info(\"Thread extentions: \" + System.currentTimeMillis()); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; new一个Thread实例的时候，所有构造方法最终都是调用Thread的init方法， init方法中，设置线程属性，校验相关权限： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) &#123;/**设置线程名字,匿名线程，名字自动生成：Thread-nextThreadNum()**/ if (name == null) &#123; throw new NullPointerException(\"name cannot be null\"); &#125; this.name = name;/**设置线程组**/ Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) &#123; if (security != null) &#123; g = security.getThreadGroup(); &#125; if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; g.checkAccess(); //检查当前线程(parent)是否有权限修改线程组g if (security != null) &#123; //校验是否thread子类的getContextClassLoader被覆盖 if (isCCLOverridden(getClass())) &#123; //并且拥有enableContextClassLoaderOverride权限 security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); //增加线程组的unstarted线程计数 this.group = g; //设置线程组/**继承当前线程(parant)的是否后台线程、设置优先级的值**/ this.daemon = parent.isDaemon(); this.priority = parent.getPriority();/**设置contextClassLoader和继承accessControlContext**/ if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext();/**设置Runnable接口的实例，作为target对象**/ this.target = target;/**这里才是真正设置优先级的地方**/ setPriority(priority);/**继承当前线程(parent)的ThreadLocal.ThreadLocalMap**/ if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); this.stackSize = stackSize;/**设置线程id, 这里设置的是tid，跟nextThreadNum()设置的threadInitNumber是两个值**/ tid = nextThreadID(); &#125; 启动线程需要调用start方法，方法中调用native方法start0真正启动线程，虚拟机会在线程启动过程中回调Thread的run方法： 123456789101112131415161718192021222324 public synchronized void start() &#123; /**threadStatus不等于0, 状态异常，非NEW状态的线程*/ if (threadStatus != 0) throw new IllegalThreadStateException(); /**将线程加入到线程组，减线程组的unstarted计数器**/ group.add(this); boolean started = false; try &#123; /**native方法启动线程**/ start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; /**移出线程组，增加unstarted计数器**/ group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /** do nothing. start0的异常会直接抛出 **/ &#125; &#125; &#125;/**启动线程的native方法**/ private native void start0(); Thread本身也实现了Runnable接口, 实现run方法，虚拟机启动时，调用的就是该实现方法。 单纯从target看，Thread和Runnable的关系看，这是简单的模板方法模式的实现。 这也引出了第二种实现方式，实现Runnable接口或者实现/继承Runnable接口的子接口/子类。 所以继承Thread实现run和实现Runnable接口实现run方法是有本质区别的，Thread的run是被虚拟机调用的，Runnable的run是作为thread的target属性的模板方法被调用的。 1234567@Overridepublic void run() &#123; /**如果target不为空，调用target的run方法**/ if (target != null) &#123; target.run(); &#125;&#125; 二、实现或继承Runnable接口的子接口或实现类实现多线程的另外方式是实现或继承Runnable接口的子接口或实现类 1、继承Runnable接口直接实现Runnable接口的问题是，线程执行完成后，无法获取到线程执行结果。 12345678910111213141516171819202122232425262728293031 /** * 实现线程方式： 2、实现Runnable接口 */Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; log.info(\"Runnable implements 1: \" + System.currentTimeMillis()); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; log.error(e.getMessage(), e); &#125; &#125; &#125;&#125;); thread2.start();/** * 实现线程方式： jdk1.8之后，可以更简单的写法 */Thread thread3 = new Thread(() -&gt; &#123; while (true) &#123; log.info(\"Runnable implements 2: \" + System.currentTimeMillis()); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; log.error(e.getMessage(), e); &#125; &#125;&#125;); thread3.start(); 2、继承FutureTask接口如果需要获取线程执行结果， 可以实现FutureTask接口, 并通过FutureTask的get方法获取执行结果：123456789101112/** * 实现线程方式： 3、实现Callable接口，配合FutureTask，获取线程执行结果 */FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Fibonacci(10));Thread thread4 = new Thread(task);thread4.start();try &#123; Integer result = task.get(); log.info(\"FutureTask result: &#123;&#125;\" , result);&#125; catch (ExecutionException e) &#123; log.error(e.getMessage(), e);&#125; FutureTask相关的源码研究，后续分析。 3、继承TimerTask接口如果需要在主线程外执行一些任务的话，可以使用TimerTask接口,配合定时器工具Timer实现，Timer内部维护一个TimerThread线程，用于执行调度任务：12345678910/** * 实现线程方式：4、调度执行任务 */Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; log.info(\"TimerTask execute: &#123;&#125;\", System.currentTimeMillis()); &#125;&#125;, 5000, 3000); 简单的应用可以使用Timer，复杂需求应该引入框架。 三、Executor框架JDK1.5引入Executor异步执行框架，灵活强大，支持多种任务执行策略，将任务提交和执行解耦，可以通过submit和execute提交任务给线程池执行。Executors提供一系列创建线程池的工厂方法。 后续对Executor框架进行分析 123456789101112131415161718192021222324252627/** * 实现多线程的方式： 5、java.util.concurrent包提供的Executor框架,创建线程池，执行任务 */ExecutorService executorService = Executors.newFixedThreadPool(5);//通过execute执行实现Runnable接口的任务for(int i = 0; i &lt; 100; i++) &#123; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(\"ThreadPool execute task: &#123;&#125; &#123;&#125;\", Thread.currentThread().getName(), System.currentTimeMillis()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; log.error(e.getMessage(), e); &#125; &#125; &#125;);&#125;//也可以通过submit实现Callable接口的任务，以便获取线程执行结果Future&lt;Integer&gt; fiboResult = executorService.submit(new Fibonacci(10)); try &#123; log.info(\"ThreadPool submit task: &#123;&#125;\",fiboResult.get());&#125; catch (ExecutionException e) &#123; log.error(e.getMessage(), e);&#125; 四、ForkJoin框架如果大任务可以分解成小任务并行计算，可以实现RecursiveTask接口，提交到ForJoin框架执行。 123456789101112131415161718192021222324252627282930313233343536public static void useForkJoinFramework() &#123; long start = System.currentTimeMillis(); ForkJoinPool pool = new ForkJoinPool(); Long result = pool.invoke(createNewTask(0L, 10000000000L, 1000000000L)); log.info(\"ForkJoinPool execute result: &#123;&#125; &#123;&#125;\", result , (System.currentTimeMillis() - start)); start = System.currentTimeMillis(); long sum = 0; for(long i = 0;i &lt;= 10000000000L; i++) &#123; sum += i; &#125; log.info(\"Simple sum: &#123;&#125; &#123;&#125;\", sum, (System.currentTimeMillis() - start));&#125;@SuppressWarnings(\"serial\")public static RecursiveTask&lt;Long&gt; createNewTask(final Long start, final Long end, final Long critical)&#123; return new RecursiveTask&lt;Long&gt;() &#123; @Override protected Long compute() &#123; if(end - start &lt;= critical) &#123; long sum = 0L; for(long l = start; l &lt;= end; l++) &#123; sum += l; &#125; return sum; &#125;else &#123; Long middle = (end + start) / 2; RecursiveTask&lt;Long&gt; left = createNewTask(start, middle, critical); RecursiveTask&lt;Long&gt; right = createNewTask(middle+1, end, critical); left.fork(); right.fork(); return left.join()+right.join(); &#125; &#125; &#125;;&#125; RecursiveTask接口继承自ForkJoinTask接口， ForkJoinTask继承Future接口。 五、总结Java中多线程编程主要分两类： 通过创建Thread实例创建线程和start()方法启动线程，自己管理线程，执行任务； 通过Executor框架创建线程池，或者实现相关接口，通过线程池管理管理线程执行任务； 通过ForkJoin框架并行执行任务。不管是通过哪种方式， 都有支持Runnable接口提交任务和支持Callable接口的方式，jdk1.8之后，还可以通过lambda表达式提交任务，编程上弱化了Runnable和Callable的区别，所以选用哪种方式去创建线程和管理线程，取决于： 场景是否足够简单，只需简单管理线程，还是需要强大的线程管理功能？ 是否需要线程执行结果，可以Future相关的API？ 是否可以并行执行？","categories":[{"name":"并发编程","slug":"并发编程","permalink":"http://yoursite.com/categories/并发编程/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://yoursite.com/tags/并发编程/"},{"name":"java多线程","slug":"java多线程","permalink":"http://yoursite.com/tags/java多线程/"},{"name":"Thread","slug":"Thread","permalink":"http://yoursite.com/tags/Thread/"},{"name":"FutureTask","slug":"FutureTask","permalink":"http://yoursite.com/tags/FutureTask/"},{"name":"Runnable","slug":"Runnable","permalink":"http://yoursite.com/tags/Runnable/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"http://yoursite.com/categories/并发编程/"}]},{"title":"Dockerfile构建jdk镜像和tomcat镜像","slug":"create-jdk-docker-image","date":"2018-09-26T23:30:53.000Z","updated":"2019-10-17T02:09:56.824Z","comments":true,"path":"2018/09/26/create-jdk-docker-image/","link":"","permalink":"http://yoursite.com/2018/09/26/create-jdk-docker-image/","excerpt":"","text":"[TOC] 一、用vagrant up拉起一个基于docker的centos7虚拟机12345678910111213141516171819# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(\"2\") do |config| config.vm.box = \"centos7-base-docker\" config.vm.hostname=\"centos7-docker-standalone\" config.vm.synced_folder \"./share\", \"/home/vagrant/share\" config.vm.network \"private_network\", ip: \"192.168.10.10\" config.vm.provider \"virtualbox\" do |v| v.name = \"centos7-docker-standalone\" v.memory = 4096 v.cpus = 2 endend 二、拉取一个centos7的镜像123$ docker pull centos$ docker run -it centos /bin/bash /]# cat /etc/redhat-release 三、准备Dockerfile，构建centos7-jdk8镜像并验证1、准备Dockerfile123456789FROM centosMAINTAINER jacky zhengENV REFRESHED_AT 2018-09-25 23:45ADD jdk-8u181-linux-x64.tar.gz /usr/java/ENV JAVA_HOME /usr/java/jdk1.8.0_181ENV CLASSPATH $JAVA_HOME/lib;$JAVA_HOME/jre/libENV PATH $PATH:$JAVA_HOME/bin 2、利用docker build -t jacky/centos7-jdk8 . 构建镜像1$ docker build -t jacky/centos7-jdk8 . 3、验证构建的镜像是否正确123$ docker run -it jacky/centos7-jdk8 /bin/bash /]# java -version /]# javac -version 四、利用构建的jdk镜像，构建tomcat镜像1、准备构建tomcat镜像的Dockerfile123456789101112131415FROM jacky/centos7-jdk8MAINTAINER jacky zheng ENV REFRESHED_AT 2018-09-26 22:45ADD apache-tomcat-9.0.12.tar.gz /usr/tomcat/ENV CATALINA_HOME /usr/tomcat/apache-tomcat-9.0.12ENV CATALINA_BASE $CATALINA_HOMEENV PATH $PATH:$CATALINA_HOME/lib:$CATALINA_HOME/bin#暴露端口8080EXPOSE 8080#启动时运行tomcatCMD [\"/usr/tomcat/apache-tomcat-9.0.12/bin/catalina.sh\", \"run\"] 2、构建tomcat镜像，并验证123456$ ls -l$ docker images$ docker ps -a$ docker build -t jacky/centos7-tomcat9 .$ docker images$ docker run -d -p 8081:8080 --name tomcat9-test jacky/centos7-tomcat9","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"jdk镜像","slug":"jdk镜像","permalink":"http://yoursite.com/tags/jdk镜像/"},{"name":"tomcat镜像","slug":"tomcat镜像","permalink":"http://yoursite.com/tags/tomcat镜像/"},{"name":"docker镜像","slug":"docker镜像","permalink":"http://yoursite.com/tags/docker镜像/"}],"keywords":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}]},{"title":"zookeeper安装：单机模式、伪集群模式、集群模式","slug":"centos7-install-zookeeper","date":"2018-09-23T13:34:39.000Z","updated":"2019-10-17T02:09:56.810Z","comments":true,"path":"2018/09/23/centos7-install-zookeeper/","link":"","permalink":"http://yoursite.com/2018/09/23/centos7-install-zookeeper/","excerpt":"","text":"zookeeper的安装分为三种模式： 单机模式、伪集群模式和集群模式。 安装需要用到的zookeeper文件，到http://zookeeper.apache.org/通过download链接下载。 一、单机模式安装zookeeper1、设置环境变量 123456789$ ZK_FILE=/vagrant/zookeeper-3.4.13.tar.gz$ ZK_INSTALL_PATH=/opt/zk$ ZK_INSTALL_DIR=$ZK_INSTALL_PATH/zookeeper-3.4.13$ ZK_DATA_DIR=$ZK_INSTALL_PATH/zookeeper-3.4.13/data $ ZK_LOG_DIR=$ZK_INSTALL_PATH/zookeeper-3.4.13/log$ ZK_CFG=$ZK_INSTALL_DIR/conf/zoo.cfg $ ZK_SERVER_ID=1$ ZK_PORT=2181$ ZK_SERVER_LIST=server.1=127.0.0.1:2888:3888 2、创建安装目录并将zk到解压安装目录 123$ mkdir -p $ZK_INSTALL_PATH $ tar -zxvf $ZK_FILE -C $ZK_INSTALL_PATH &gt;&gt; /var/null$ ls -l $ZK_INSTALL_PATH 3、新建数据和日志目录，生成myid文件，拷贝配置zoo.cfg文件12345$ mkdir $ZK_DATA_DIR$ mkdir $ZK_LOG_DIR$ echo $ZK_SERVER_ID &gt;&gt; $ZK_DATA_DIR/myid$ cp $ZK_INSTALL_DIR/conf/zoo_sample.cfg $ZK_CFG$ cat $ZK_CFG 4、配置zoo.cfg数据目录、日志目录、端口号、服务器列表并确认配置123456$ sed -i 's#dataDir=/tmp/zookeeper#dataDir='$ZK_DATA_DIR'#' $ZK_CFG$ sed -i '$a \\dataLogDir='$ZK_LOG_DIR $ZK_CFG$ sed -i 's/2181/'$ZK_PORT'/g' $ZK_CFG$ sed -i '$a \\'$ZK_SERVER_LIST $ZK_CFG$ cat $ZK_CFG 5、启动zk并查看状态12$ sh $ZK_INSTALL_DIR/bin/zkServer.sh start $ sh $ZK_INSTALL_DIR/bin/zkServer.sh status 6、利用zkCli操作zk1$ sh $ZK_INSTALL_DIR/bin/zkCli.sh 可以输入以下命令进行操作, 查看结果123&gt; ls / &gt; create /test value1&gt; get /test 二、通过vagrant一键安装单机版的zookeeper1、整理一中的shell命令成zk-install.sh脚本文件12345678910111213141516171819202122232425262728293031323334353637383940echo \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;zk压缩包路径&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo $ZK_FILEecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;zk安装路径&amp;安装目录&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo $ZK_INSTALL_PATHecho $ZK_INSTALL_DIRecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;zk数据目录&amp;日志目录&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo $ZK_DATA_DIRecho $ZK_LOG_DIRecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;zk的myid&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo $ZK_SERVER_IDecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;zk端口及服务器列表&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo $ZK_PORTecho $ZK_SERVER_LISTecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;zk配置文件&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"ZK_CFG=$ZK_INSTALL_DIR/conf/zoo.cfgecho $ZK_CFGecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;新建zk安装目录并解压zk到该目录&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" mkdir -p $ZK_INSTALL_PATH tar -zxvf $ZK_FILE -C $ZK_INSTALL_PATH &gt;&gt; /var/nullecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;新建zk数据和日志目录及myid&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" mkdir $ZK_DATA_DIRmkdir $ZK_LOG_DIRecho $ZK_SERVER_ID &gt;&gt; $ZK_DATA_DIR/myidecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;配置zoo.cfg&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" cp $ZK_INSTALL_DIR/conf/zoo_sample.cfg $ZK_CFGsed -i 's#dataDir=/tmp/zookeeper#dataDir='$ZK_DATA_DIR'#' $ZK_CFGsed -i '$a \\dataLogDir='$ZK_LOG_DIR $ZK_CFGsed -i 's/2181/'$ZK_PORT'/g' $ZK_CFGsed -i '$a \\'$ZK_SERVER_LIST $ZK_CFGtail -n 20 $ZK_CFGecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动zk&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" sh $ZK_INSTALL_DIR/bin/zkServer.sh start 2、新建Vagrantfile文件12345678910111213141516171819202122232425262728293031323334353637# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(\"2\") do |config| #设置虚拟机的box config.vm.box = \"centos7-base-jdk8\" #设置虚拟机的主机名 config.vm.hostname = \"centos7-jdk8-zk-standalone\" #设置ip config.vm.network \"private_network\", ip: \"192.168.13.10\" #Virtualbox相关配置 config.vm.provider \"virtualbox\" do |v| #设置虚拟机的名称 v.name = \"centos7-jdk8-zk-standalone\" #设置虚拟机的内存大小为2G v.memory = 2048 #设置虚拟机的CPU个数 v.cpus = 2 end #使用shell脚本进行软件安装和配置 config.vm.provision \"shell\" do |s| s.path = \"zk-install.sh\" s.env = &#123;ZK_FILE: \"/vagrant/zookeeper-3.4.13.tar.gz\", ZK_INSTALL_PATH: \"/opt/zk\", ZK_INSTALL_DIR: \"/opt/zk/zookeeper-3.4.13\", ZK_PORT: \"2181\", ZK_DATA_DIR: \"/opt/zk/zookeeper-3.4.13/data\", ZK_LOG_DIR: \"/opt/zk/zookeeper-3.4.13/log\", ZK_SERVER_ID: \"1\", ZK_SERVER_LIST: \"server.1=127.0.0.1:2888:3888\"&#125; endend 3、通过vagrant up启动虚拟机 三、通过vagrant一键安装zookeeper伪集群1、zk伪集群指的是在一台集群上安装zk集群需要注意每个zk进程对外端口（默认2181，用于客户端链接zk集群），选主端口（默认3888-进行leader选举时使用的端口），集群通信端口（默认2888-集群follow链接leader的通信端口）配置不冲突。myid=1, 2181, 2888, 3888myid=2, 2182, 2887, 3887myid=3, 2183, 2886, 3886 2、zk-install.sh同二使用的是相同内容，Vagrantfile如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# -*- mode: ruby -*-# vi: set ft=ruby : Vagrant.configure(\"2\") do |config| #设置虚拟机的box config.vm.box = \"centos7-base-jdk8\" #设置虚拟机的主机名 config.vm.hostname = \"centos7-jdk-zk-local-cluster\" #Virtualbox相关配置 config.vm.provider \"virtualbox\" do |v| #设置虚拟机的名称 v.name = \"centos7-jdk-zk-local-cluster\" #设置虚拟机的内存大小为1G v.memory = 2048 #设置虚拟机的CPU个数 v.cpus = 2 end (1..3).each do |i| #使用shell脚本进行软件安装和配置 config.vm.provision \"shell\" do |s| s.path = \"zk-install.sh\" s.env = &#123;ZK_FILE: \"/vagrant/zookeeper-3.4.13.tar.gz\", ZK_INSTALL_PATH: \"/opt/zk/zk-server#&#123;i&#125;\", ZK_INSTALL_DIR: \"/opt/zk/zk-server#&#123;i&#125;/zookeeper-3.4.13\", ZK_PORT: \"218#&#123;i&#125;\", ZK_DATA_DIR: \"/opt/zk/zk-server#&#123;i&#125;/zookeeper-3.4.13/data\", ZK_LOG_DIR: \"/opt/zk/zk-server#&#123;i&#125;/zookeeper-3.4.13/log\", ZK_SERVER_ID: \"#&#123;i&#125;\", ZK_SERVER_LIST: \"server.1=127.0.0.1:2888:3888\\\\nserver.2=127.0.0.1:2887:3887\\\\nserver.3=127.0.0.1:2886:3886\"&#125; end end end``` 3、同样使用vagrant up 命令，可以启动虚拟机，并自动安装 4、ssh进入虚拟机， 查看各个目录下对应的zk安装情况可以看到，zk-server2作为leader节点， 其他两个节点作为follower节点![zk-local-cluster-status ][10] 5、可以通过xshell给三个节点的zkCli.sh 分别发送命令，![zk-local-cluster-cli ][11] 四、通过vagrant一键安装zookeeper集群1、集群ip规划 zk_server1 =&gt; 1 192.168.13.21 centos7-jdk-zk-cluster-1zk_server2 =&gt; 2 192.168.13.22 centos7-jdk-zk-cluster-2 zk_server3 =&gt; 3 192.168.13.23 centos7-jdk-zk-cluster-32、zk-install.sh同二使用的是相同内容，Vagrantfile如下： ``` ruby# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(\"2\") do |config| #设置虚拟机的box config.vm.box = \"centos7-base-jdk8\" zk_servers = &#123; :zk_server1 =&gt; [\"192.168.13.21\", \"1\", \"centos7-jdk-zk-cluster-1\"], :zk_server2 =&gt; [\"192.168.13.22\", \"2\", \"centos7-jdk-zk-cluster-2\"], :zk_server3 =&gt; [\"192.168.13.23\", \"3\", \"centos7-jdk-zk-cluster-3\"] &#125; zk_server_list = \"server.1=192.168.13.21:2888:3888\\\\nserver.2=192.168.13.22:2888:3888\\\\nserver.3=192.168.13.23:2888:3888\" zk_servers.each do |zk_server_name, zk_server_cfg| config.vm.define zk_server_name do |app_config| #设置虚拟机的主机名 app_config.vm.hostname = zk_server_cfg[2] #设置ip app_config.vm.network \"private_network\", ip: zk_server_cfg[0] #Virtualbox相关配置 app_config.vm.provider \"virtualbox\" do |v| #设置虚拟机的名称 v.name = zk_server_cfg[2] #设置虚拟机的内存大小为1G v.memory = 1048 #设置虚拟机的CPU个数 v.cpus = 2 end #使用shell脚本进行软件安装和配置 app_config.vm.provision \"shell\" do |s| s.path = \"zk-install.sh\" s.env = &#123;ZK_FILE: \"/vagrant/zookeeper-3.4.13.tar.gz\", ZK_INSTALL_PATH: \"/opt/zk\", ZK_INSTALL_DIR: \"/opt/zk/zookeeper-3.4.13\", ZK_PORT: \"2181\", ZK_DATA_DIR: \"/opt/zk/zookeeper-3.4.13/data\", ZK_LOG_DIR: \"/opt/zk/zookeeper-3.4.13/log\", ZK_SERVER_ID: zk_server_cfg[1], ZK_SERVER_LIST: zk_server_list&#125; end end end end 3、通过vagrant up 拉起三台虚拟机，并自动安装zk安装完毕后，进入虚拟机，确认是否安装正确 OK, 到这里就结束了， 三种模式的安装通过vagrant可以快速安装实验环境。","categories":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/categories/zookeeper/"}],"tags":[{"name":"vagrant","slug":"vagrant","permalink":"http://yoursite.com/tags/vagrant/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/tags/zookeeper/"}],"keywords":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/categories/zookeeper/"}]},{"title":"Centos7安装jdk8并制作box镜像","slug":"centos7-install-jdk-build-box","date":"2018-09-19T00:24:51.000Z","updated":"2019-10-17T02:09:56.804Z","comments":true,"path":"2018/09/19/centos7-install-jdk-build-box/","link":"","permalink":"http://yoursite.com/2018/09/19/centos7-install-jdk-build-box/","excerpt":"","text":"一、centos7安装jdk1、下载jdk安装文件https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 2、解压jdk到安装目录12345$ mkdir /usr/java$ touch /vagrant/jdk-install.log $ tar -zxvf /vagrant/jdk-8u181-linux-x64.tar.gz -C /usr/java &gt;&gt; /vagrant/jdk-install.log $ tail -n 10 /vagrant/jdk-install.log $ ls -l /usr/java 3、设置环境变量到/etc/profile123456789$ JAVA_HOME=/usr/java/jdk1.8.0_181$ JAVA_BIN=/usr/java/jdk1.8.0_181/bin$ echo \"export JAVA_HOME=\"$JAVA_HOME &gt;&gt;/etc/profile$ echo \"export JAVA_BIN=\"$JAVA_BIN &gt;&gt;/etc/profile$ echo \"export PATH=\\$PATH:\\$JAVA_BIN\" &gt;&gt;/etc/profile$ echo \"export CLASSPATH=.:\"\\$JAVA_HOME/lib:\\$JAVA_HOME/jre/lib &gt;&gt;/etc/profile$ tail -n 10 /etc/profile 4、验证安装12$ source /etc/profile$ java -version 二、通过vagrant一键式安装将一中的脚本执行过程制作成脚本，在vagrantfile中直接引用执行脚本，一键安装shell脚本jdk-install.sh如下：12345678910111213141516171819202122232425262728293031323334echo \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;jdk压缩包路径&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo $JDK_FILEecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;jdk安装路径&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo $JDK_INSTALL_PATHecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;创建目录并解压jdk压缩包到安装路径&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo $JDK_INSTALL_DIRmkdir $JDK_INSTALL_DIRtouch $JDK_INSTALL_DIR/jdk-install.log tar -zxvf $JDK_FILE -C $JDK_INSTALL_DIR &gt;&gt; $JDK_INSTALL_DIR/jdk-install.log tail -n 10 $JDK_INSTALL_DIR/jdk-install.log ls -l $JDK_INSTALL_DIRecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;设置环境变量&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"JAVA_HOME=$JDK_INSTALL_PATHJAVA_BIN=$JDK_INSTALL_PATH/binecho $JAVA_HOMEecho $JAVA_BINecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;设置环境变量到/etc/profile&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"echo \"export JAVA_HOME=\"$JAVA_HOME &gt;&gt;/etc/profileecho \"export JAVA_BIN=\"$JAVA_BIN &gt;&gt;/etc/profileecho \"export PATH=\\$PATH:\\$JAVA_BIN\" &gt;&gt;/etc/profileecho \"export CLASSPATH=.:\"\\$JAVA_HOME/lib:\\$JAVA_HOME/jre/lib &gt;&gt;/etc/profiletail -n 10 /etc/profileecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;source一下让设置生效&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"source /etc/profileecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;看下java命令是否可用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"java -versionjavac -version echo \"&gt;&gt;&gt;默认的公钥在启动的时候会被移除,作为base的box,用默认公钥方便ssh登录&gt;&gt;&gt;\"curl https://raw.githubusercontent.com/mitchellh/vagrant/master/keys/vagrant.pub &gt;&gt; /home/vagrant/.ssh/authorized_keys Vagrantfile内容如下：123456789101112131415161718192021222324252627282930# -*- mode: ruby -*-# vi: set ft=ruby : Vagrant.configure(\"2\") do |config| #设置虚拟机的box config.vm.box = \"centos7-base\" #设置虚拟机的主机名 config.vm.hostname = \"centos7-base-jdk\" #Virtualbox相关配置 config.vm.provider \"virtualbox\" do |v| #设置虚拟机的名称 v.name = \"centos7-base-jdk\" #设置虚拟机的内存大小为2G v.memory = 2048 #设置虚拟机的CPU个数 v.cpus = 2 end #使用shell脚本进行软件安装和配置 config.vm.provision \"shell\" do |s| s.path = \"jdk-install.sh\" s.env = &#123;JDK_FILE: \"/vagrant/jdk-8u181-linux-x64.tar.gz\", JDK_INSTALL_DIR: \"/usr/java\", JDK_INSTALL_PATH: \"/usr/java/jdk1.8.0_181\"&#125; end end vagrant up拉起虚拟机，自动安装jdk， 安装结果： 三、打包centos7-base-jdk成box，并加入到box list创建一个目录，然后打开命令行，打包虚拟机成box，–base的参数必须是安装的centos7的虚拟机名称，本次是centos7-base-jdk。再将生成的box添加到box list中，后续就可以直接使用centos7-base-jdk8作为镜像创建虚拟机了。123$ vagrant package --output centos7-base-jdk8.box --base centos7-base-jdk$ vagrant box add centos7-base-jdk8 centos7-base-jdk8.box$ vagrant box list","categories":[{"name":"折腾过程","slug":"折腾过程","permalink":"http://yoursite.com/categories/折腾过程/"}],"tags":[{"name":"vagrant","slug":"vagrant","permalink":"http://yoursite.com/tags/vagrant/"},{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"},{"name":"virtualbox","slug":"virtualbox","permalink":"http://yoursite.com/tags/virtualbox/"},{"name":"vagrant box","slug":"vagrant-box","permalink":"http://yoursite.com/tags/vagrant-box/"},{"name":"jdk8","slug":"jdk8","permalink":"http://yoursite.com/tags/jdk8/"}],"keywords":[{"name":"折腾过程","slug":"折腾过程","permalink":"http://yoursite.com/categories/折腾过程/"}]},{"title":"hexo安装、生成blog并deploy到github","slug":"use-hexo-gen-blog-deploy-github","date":"2018-09-16T23:23:01.000Z","updated":"2019-10-17T02:09:56.960Z","comments":true,"path":"2018/09/16/use-hexo-gen-blog-deploy-github/","link":"","permalink":"http://yoursite.com/2018/09/16/use-hexo-gen-blog-deploy-github/","excerpt":"","text":"一、安装 nodejs从https://nodejs.org/en/download/下载nodejs, 安装一路下一步就ok 二、安装hexo安装完nodejs后， 用npm安装hexo。 12$npm install -g hexo-cli $hexo -v 三、用hexo初始化并生成blog1、用hexo初始化并生成blog1$hexo init jack-demo 2、安装依赖，然后用hexo generate， 也可以用缩写hexo g生成静态页面1234$cd jacky-demo $ls -l $npm install $hexo generate 3、生成静态页面后，可以用hexo server启动服务器，并通过http://localhost:4000访问，默认主题比较丑。1$hexo server 四、更换主题成indigo1、从github clone indigo主题， clone后，安装主题需要的依赖。12345$git clone git@github.com:yscoder/hexo-theme-indigo.git themes/inidgo$npm install hexo-renderer-less --save #安装less,作为css的预处理工具$npm install hexo-generator-feed --save #安装rss的feed生成工具$npm install hexo-generator-json-content --save #用于生成静态站点数据，用于站内搜索的数据源$npm install hexo-helper-qrcode --save #用于生成微信分享二维码 2、开启标签页1$hexo new page tags 编辑source/tags/index.md，增加layout和comments 3、开启分类页1$hexo new page categories 编辑source/categories/index.md，增加layout和comments 4、修改_config.yml，使用indigo主题 注意： _config.yml的author改成自己，indigo会用来显示昵称， themes/indigo/_config.yml里的email改成自己的email 5、重新生成静态页面并启动服务器(需要调试信息可以使用，hexo s –debug)1$hexo clean &amp; hexo g &amp; hexo s 6、效果如下： 五、注册github并配置ssh到https://github.com/ 注册账号，然后配置ssh登录。1、配置git的登录信息 12$git config --global user.name \"你的git用户名\"$git config --global user.email \"你的git登录邮箱\" 2、生成ssh公私钥 1$ssh-keygen -t rsa -C \"你的git登录邮箱\" 3、设置github的ssh key将id_rsa.pub的内容拷贝到github的ssh key中 4、测试链接github设置的ssh key免登陆是否生效 1$ssh -T git@github.com 六、上传博客到github1、新增git仓库github上新建一个以注册的昵称开头的repository。 比如演示用的昵称是jacky-dmeo， repository的名称是jacky-demo.github.io 。 2、配置deploy的地址type为git， repository配置为1新增的git仓库地址 3、安装hexo deploy插件1$ npm install hexo-deployer-git --save 4、上传到github1$hexo deploy 5、查看github的博客，看下效果","categories":[{"name":"github 博客","slug":"github-博客","permalink":"http://yoursite.com/categories/github-博客/"}],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"github pages","slug":"github-pages","permalink":"http://yoursite.com/tags/github-pages/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"github 博客","slug":"github-博客","permalink":"http://yoursite.com/categories/github-博客/"}]},{"title":"github配置ssh及多ssh key问题处理","slug":"github-multi-ssh-key","date":"2018-09-16T22:49:51.000Z","updated":"2019-10-17T02:09:56.878Z","comments":true,"path":"2018/09/16/github-multi-ssh-key/","link":"","permalink":"http://yoursite.com/2018/09/16/github-multi-ssh-key/","excerpt":"","text":"一、生成ssh公私钥用ssh-keygen生成公私钥。1$ssh-keygen -t rsa -C \"你的邮箱\" -f ~/.ssh/id_rsa_mult 在~/./ssh目录下会生成一对文件id_rsa_mult和id_rsa_mult.pub文件 二、编辑config文件，增加多用户支持在ssh用户的配置文件~/.ssh/config增加github-mult.com的配置12$touch config $vi config 三、 解决Enter passphrase for key 问题在后续使用id_rsa_mult过程中，会出现输入私钥的key， 在事先可以将key加入，解决该问题 123456$ssh-agent bash $ssh-add -l #列出已经添加的key $ssh-add -D #清理下 $ssh-add ~/.ssh/id_rsa #添加id_rsa秘钥$ssh-add ~/.ssh/id_rsa_mult #添加id_rsa_mult秘钥 $ssh-add -l 四、配置github的公钥 通过ssh -T git@github-mult.com 确认是否配置正确：1$ssh -T git@github-mult.com 注意： 是git@github-mult，不是git@github.com， git仓库地址复制过来后也要改一下测试clone仓库：1$git clone git@github-mult.com:xxxx/xxxx.github.io.git","categories":[{"name":"github 博客","slug":"github-博客","permalink":"http://yoursite.com/categories/github-博客/"}],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"},{"name":"ssh key","slug":"ssh-key","permalink":"http://yoursite.com/tags/ssh-key/"}],"keywords":[{"name":"github 博客","slug":"github-博客","permalink":"http://yoursite.com/categories/github-博客/"}]},{"title":"Centos7安装Docker","slug":"install-docker-in-centos7","date":"2018-04-15T22:45:05.000Z","updated":"2019-10-17T02:09:56.913Z","comments":true,"path":"2018/04/15/install-docker-in-centos7/","link":"","permalink":"http://yoursite.com/2018/04/15/install-docker-in-centos7/","excerpt":"","text":"一、安装Docker关于docker介绍的文章非常多，这里就不详细介绍了。 从1.13版本开始，docker分为社区版本CE和企业版本EE。版本号采用时间线命名方法。社区版本按照stable和edge两种方式发布， 每个季度发布stable版本。 docker（version 18.03.0-ce）要求CentOS7， linux内核版本&gt;=3.10。 1. 两种方式安装docker安装比较简单，可以有两种方式进行安装a. 手动按步骤安装12345678910111213141516#生成缓存sudo yum makecache fast#Delta RPMs disabled because /usr/bin/applydeltarpm not installed 增量rpm包相关sudo yum provides &apos;*/applydeltarpm&apos;sudo yum install -y deltarpm#升级包和内核sudo yum -y update#yum-util 提供yum-config-manager功能sudo yum install -y -q yum-utils#添加docker的reposudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install -y docker-ce b. 在线脚本安装12#安装docker#sudo wget -qO- https://get.docker.com | sh 其实，安装方式a跟安装方式b下载的脚本中的安装过程类似，如果有兴趣可以将get.docker.com下载的脚本保存下来，这个脚本兼容各类操作系统的安装。 2. 设置开机启动和启动docker service12#设置docker服务启动后自运行 启动docker服务sudo systemctl enable docker &amp;&amp; sudo systemctl start docker 3. 开放管理端口和设置mirror123456789#设置mirror#开放管理端口映射237 5为主管理端口，unix:///var/run/docker.sock用于本地管理，7654是备用的端口sudo sed -i -e &apos;s!^ExecStart=/usr/bin/dockerd!ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock -H tcp://0.0.0.0:7654 --registry-mirror=https://docker.mirrors.ustc.edu.cn!&apos; /lib/systemd/system/docker.servicesudo systemctl daemon-reloadsudo echo &apos;export DOCKER_HOST=tcp://0.0.0.0:2375&apos; &gt;&gt; /etc/profile source /etc/profilesudo systemctl restart docker 4. 添加用户(vagrant)到docker权限组12#添加vagrant用户添加到docker权限组sudo usermod -aG docker vagrant 5. 安装结果12345678#测试docker安装结果 查看安装版本docker -v#拉取hello-world镜像docker pull hello-world#运用hello-world容器docker run hello-world 看到以下结果，说明运行成功 二、vagrant自动安装如果已经安装了vagrant，可以将上述安装过程自动化，并且安装完成后可以到处box镜像，后续安装docker集群或者创建带docker的虚拟机，都可以很方便操作。以下脚本基于制作一个CentOS7的Vagrant Box生成的centos7-base box。 1. 自动化安装的Vagrantfilea. 创建目录并保存vagrantfile到目录中b. 运行vagrant up命令，并耐心等待几分钟，中间需要升级包和内核、安装docker， 过程会比较久，是网速而定。 ====================================Vagrantfile====================================1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# -*- mode: ruby -*-# vi: set ft=ruby :$script = &lt;&lt;-SCRIPT#centos7-base默认配置了 使用163的centos源 #sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup #sudo wget http://mirrors.163.com/.help/CentOS7-Base-163.repo -O /etc/yum.repos.d/CentOS-Base.repo#======================安装方式1============================#生成缓存sudo yum makecache fast #Delta RPMs disabled because /usr/bin/applydeltarpm not installed 增量rpm包相关sudo yum provides &apos;*/applydeltarpm&apos;sudo yum install -y deltarpm #升级包和内核sudo yum -y update#yum-util 提供yum-config-manager功能sudo yum install -y -q yum-utils #添加docker的reposudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install -y docker-ce#======================安装方式2=================================#安装docker #sudo wget -qO- https://get.docker.com | sh #======================安装完成==================================#设置docker服务启动后自运行 启动docker服务sudo systemctl enable docker &amp;&amp; sudo systemctl start docker#设置mirror#开放管理端口映射237 5为主管理端口，unix:///var/run/docker.sock用于本地管理，7654是备用的端口sudo echo &quot;====set docker manager port and mirror start====&quot;sudo sed -i -e &apos;s!^ExecStart=/usr/bin/dockerd!ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock -H tcp://0.0.0.0:7654 --registry-mirror=https://docker.mirrors.ustc.edu.cn!&apos; /lib/systemd/system/docker.servicesudo echo &quot;====set docker manager port and mirror end====&quot; &amp;&amp; sudo systemctl daemon-reloadsudo echo &apos;export DOCKER_HOST=tcp://0.0.0.0:2375&apos; &gt;&gt; /etc/profile sudo echo &quot;====docker host====&quot; &amp;&amp; source /etc/profilesudo systemctl restart docker#添加vagrant用户添加到docker权限组sudo usermod -aG docker vagrant #默认的公钥在启动的时候会被移除（在vagrant up的时候可以看到下面的提示信息），如果需要自己生产公私钥，去掉这一行#default: Vagrant insecure key detected. Vagrant will automatically replace#default: this with a newly generated keypair for better security.#default:#default: Inserting generated public key within guest...#default: Removing insecure key from the guest if it&apos;s present...#default: Key inserted! Disconnecting and reconnecting using new SSH key...curl https://raw.githubusercontent.com/mitchellh/vagrant/master/keys/vagrant.pub &gt;&gt; /home/vagrant/.ssh/authorized_keys#测试docker安装结果 查看安装版本docker -v#拉取hello-world镜像docker pull hello-world#运用hello-world容器docker run hello-world#清理包sudo yum clean allSCRIPTVagrant.configure(&quot;2&quot;) do |config| #设置虚拟机的box config.vm.box = &quot;centos7-base&quot; #设置虚拟机的主机名 config.vm.hostname = &quot;centos7-base-docker&quot; #Virtualbox相关配置 config.vm.provider &quot;virtualbox&quot; do |v| #设置虚拟机的名称 v.name = &quot;centos7-base-docker&quot; #设置虚拟机的内存大小为2G v.memory = 2048 #设置虚拟机的CPU个数 v.cpus = 2 end #使用shell脚本进行软件安装和配置 config.vm.provision &quot;shell&quot;, inline: $script end 2. 运行结果看到以下结果，说明安装成功 3. 创建centos7-base-docker的box文件12#运行 package命令， 生成box文件vagrant package --output centos7-base-docker.box --base centos7-base-docker 4. 测试box文件的可用性首先将生成的box添加到box list中， 然后用vagrant init当前目录， vagrant up拉起虚拟机，完成后，vagrant ssh链接进入虚拟机就可以操作了。 12345vagrant box add centos7-base-docker centos7-base-docker.boxvagrant box listvagrant init centos7-base-dockervagrant upvagrant ssh","categories":[{"name":"折腾过程","slug":"折腾过程","permalink":"http://yoursite.com/categories/折腾过程/"}],"tags":[{"name":"vagrant","slug":"vagrant","permalink":"http://yoursite.com/tags/vagrant/"},{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"},{"name":"virtualbox","slug":"virtualbox","permalink":"http://yoursite.com/tags/virtualbox/"},{"name":"vagrant box","slug":"vagrant-box","permalink":"http://yoursite.com/tags/vagrant-box/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[{"name":"折腾过程","slug":"折腾过程","permalink":"http://yoursite.com/categories/折腾过程/"}]},{"title":"制作一个CentOS7的Vagrant Box","slug":"How-To-Create-A-CentOS7-Vagrant-Base-Box","date":"2018-04-03T00:01:30.000Z","updated":"2019-10-17T02:09:56.802Z","comments":true,"path":"2018/04/03/How-To-Create-A-CentOS7-Vagrant-Base-Box/","link":"","permalink":"http://yoursite.com/2018/04/03/How-To-Create-A-CentOS7-Vagrant-Base-Box/","excerpt":"","text":"一、相关软件：折腾过程中需要用到以下内容：操作系统centos7的镜像，本次使用CentOS-7-x86_64-Minimal-1708.iso 虚拟机软件virtualbox, 本次使用版本VirtualBox 5.2.8 vagrant是一个基于Ruby的工具,用于创建和部署虚拟化开发环境, 本次使用版本vagrant_2.0.2_x86_64.msi 二、 虚拟机配置 内存：2G 硬盘：40G 动态分配 声音、USB： 禁用 网络： 网络地址转换（NAT)， 端口转发-&gt; ssh 宿主机：127.0.0.1 222 =&gt; 虚拟机： （空） 22 如下图 三、安装centos7 安装centos 7 默认分区 设置root密码为vagrant 四、配置centos安装后重启，进入centos配置 1. 更改网络配置，设置开机启动将ifcfg-enp0s3的ONBOOT=no，改为ONBOOT=yes 1vi /etc/sysconfig/network-scripts/ifcfg-enp0s3 以前是传统的命名eth0、eth1等, centos7里网卡代号是enp0s3，或者其他方式如enp4s0，如果觉得ifcfg-enp0s3不习惯，也可以改成ifcfg-eth0:更改grub 1# vi /etc/default/grub 在GRUB_CMDLINE_LINUX的最后，加上 net.ifnames=0 biosdevname=0 的参数 1GRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0\" 1234# grub2-mkconfig -o /boot/grub2/grub.cfg# mv /etc/sysconfig/network-scripts/ifcfg-enp0s3 /etc/sysconfig/network-scripts/ifcfg-eth0# reboot 2. 安装ssh-servera. 安装openssh-server 1234# yum -y install openssh-server# systemctl enable sshd.service# systemctl start sshd.service# systemctl status sshd.service b. 配置ssh, 没配的话连不上备份/etc/ssh/sshd_config 1# cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak c. 修改sshd_config的GSSAPIAuthentication和UseDNS 1234# sed -i -e 's/^GSSAPIAuthentication yes/GSSAPIAuthentication no/' /etc/ssh/sshd_ config# sed -i -e 's/^#UseDNS yes/UseDNS no/' /etc/ssh/sshd_ config# systemctl restart sshd.service# systemctl status sshd.service 3. 更改成163的yum源非必须步骤，yum安装慢了可以更改yum源首先，安装wget，然后，备份CentOS-Base.repo, 下载并保存163的repo成CentOS-Base.repo，然后生成缓存。 123456# yum -y install wget# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup# wget http://mirrors.163.com/.help/CentOS7-Base-163.repo # mv CentOS7-Base-163.repo /etc/yum.repos.d/CentOS-Base.repo# yum clean all# yum makecache 配置selinux将SELinux配置成permissive模式 1# sed -i -e 's/^SELINUX=.*/SELINUX=permissive/' /etc/selinux/config 5. 关闭防火墙centos7中默认用的是firewalld做防火墙，iptables如果需要的话要自己装，开发的box可以直接禁用掉firewalld。 12# systemctl stop firewalld.service# systemctl disable firewalld.service 6. 安装ntpd服务及其他服务ntpd主要用来同步时间， ntpq -p可以验证是否能够同步。centos7中，默认没有ifconfig, netstat等工具，可以安装net-tools相关工具。123456# yum install -y openssh-clients nano ntp net-tools*# systemctl enable ntpd.service# systemctl stop ntpd.service# ntpdate cn.ntp.org.cn# systemctl start ntpd.service# ntpq -p 7. 创建用户vagrant1234# useradd vagrant# passwd vagrant# groupadd admin# usermod -G admin vagrant 8. 配置sudoers将vagrant用户添加到/etc/sudoers中， 免密登录 1# echo 'vagrant ALL=(ALL) NOPASSWD: ALL' &gt;&gt; /etc/sudoers 注： 从centos6.8开始，没有Defaults requiretty的配置项目不需要sed -i ‘s/^(Defaults.*requiretty)/#\\1/‘ /etc/sudoers 9. 安装virtualbox additions首先在虚拟机上找到设备的菜单， 设备=&gt;安装增强功能，然后挂载cdrom，执行安装脚本 12345# yum install gcc bzip2 make kernel-devel-`uname -r` perl# mkdir /home/vbox# mount -t auto /dev/cdrom /home/vbox# cd /home/vbox# sh ./VBoxLinuxAdditions.run 10. 添加vagrant’s public key1234# su vagrant$ mkdir -m 0700 -p /home/vagrant/.ssh$ curl https://raw.githubusercontent.com/mitchellh/vagrant/master/keys/vagrant.pub &gt;&gt; /home/vagrant/.ssh/authorized_keys$ chmod 0600 /home/vagrant/.ssh/authorized_keys 11. 清理centos7切换回root，然后清理缓存，清理临时文件，清理命令历史，关闭虚拟机123456789101112# yum clean all# rm -rf /var/cache/yum # rm -rf /tmp/*# rm -f /var/log/wtmp /var/log/btmp# history -c# shutdown -h now``` ## 五、 vagrant创建box创建一个目录，然后打开命令行，打包虚拟机成box，--base的参数必须是安装的centos7的虚拟机名称，本次是centos7-base。``` shell$ vagrant package --output centos7-base.box --base centos7-base 六、测试box首先将生成的box添加到box list中， 然后用vagrant init当前目录， vagrant up拉起虚拟机，完成后，vagrant ssh链接进入虚拟机就可以操作了。12345$ vagrant box add centos7-base centos7-base.box$ vagrant box list$ vagrant init centos7-base$ vagrant up$ vagrant ssh","categories":[{"name":"折腾过程","slug":"折腾过程","permalink":"http://yoursite.com/categories/折腾过程/"}],"tags":[{"name":"vagrant","slug":"vagrant","permalink":"http://yoursite.com/tags/vagrant/"},{"name":"centos7","slug":"centos7","permalink":"http://yoursite.com/tags/centos7/"},{"name":"virtualbox","slug":"virtualbox","permalink":"http://yoursite.com/tags/virtualbox/"},{"name":"vagrant box","slug":"vagrant-box","permalink":"http://yoursite.com/tags/vagrant-box/"}],"keywords":[{"name":"折腾过程","slug":"折腾过程","permalink":"http://yoursite.com/categories/折腾过程/"}]},{"title":"记一次生产内存泄漏问题","slug":"one-oom-product-accident","date":"2018-03-26T23:00:40.000Z","updated":"2019-10-17T02:09:56.928Z","comments":true,"path":"2018/03/26/one-oom-product-accident/","link":"","permalink":"http://yoursite.com/2018/03/26/one-oom-product-accident/","excerpt":"","text":"时间： 2018年3月16号晚 表现现象： 客户访问非常慢到最后无法打开 pinpoint请求： 请求逐步变慢（图1），持续Full GC&amp;CPU占用率高(图2)，出现OOM（图3） 紧急措施： 加大内存、重启服务器重现问题： 测试环境模拟并发访问（10线程&amp;10000次/线程），开jmx端口&amp;Virtual VM监控（图4），问题重现，启动两三分钟后开始出现GC，后续内存持续上涨，dump堆转储文件 分析问题： MAT(Memory Analyzer tool)分析，找泄露的代码 从MAT的分析可以看出， javax.crypto.JceSecurity 的实例占用了最多的堆内存(Retained Heap | 深堆) （图5） 从dominated tree可以看到，javax.crypto.JceSecurity 的实例的retained heap占了73% （图6），主要是一个IdentityHashMap类型的属性verificationResults，放了很多org.bouncycastle.jce.provider.BouncyCastleProvider 对象， 每个的retained heap占用182712字节 （图7） 另外从virtual vm看转储堆上的线程， 有很多BLOCKED的线程， 都卡在javax.crypto.JceSecurity.getVerificationResult(JceSecurity.java:173) （图8），按现象看应该是在等待Full GC 从getVerificationResult可以看出， 只要新传入Provider都会放到verificationResults缓存起来，看调用链上（Rsa的decrypt 图11-&gt; Cipher.getInstance 图12 -&gt; JceSecurity.getVerificationResult 图13），Rsa的解密不应该每次重新new org.bouncycastle.jce.provider.BouncyCastleProvider 对象。 BouncyCastleProvider的问题（图12、13）： a. provider自己是一个java.util.Properties，将所有的预设的provider的key， value都作为property put到自己的hashtable里； b. 如果key, value都是string的话， 还将他们放到一个java.util.LinkedHashMap.LinkedHashMap&lt;String,String&gt;() 的属性 legacyStrings里； c. 在java.security.Provider.getService(String, String) 的时候， 会把legacyStrings里所有的key,value解析成ServiceKey,Service对，放到另一个java.util.LinkedHashMap.LinkedHashMap&lt;ServiceKey,Service&gt;() 的属性legacyMap里 d. 因此，每次new BouncyCastleProvider 都会产生非常多的对象和引用（占用182712字节），且缓存在JceSecurity的verificationResults没法释放。 解决问题： 按照BouncyCastleProvider 的注释，改代码，将BouncyCastleProvider实例对象作为Rsa的静态成员变量可以解决问题。 验证上线： 更改后再验证（图14），内存使用正常，CPU正常 备 注： 其实， 在重现问题，设置jmx端口，用jmeter测试的时候，已经开始在看代码， 因为最近加就只加了解密的代码，除了Cipher.getInstance(&quot;RSA&quot;, new org.bouncycastle.jce.provider.BouncyCastleProvider()); 这句，其他地方看不出来会出现内存泄露，于是，顺着看下去，就看到javax.crypto.JceSecurity.getVerificationResult 里的缓存，回头看了下BouncyCastleProvider就确定怀疑正确。 然后紧急版本线上了再说。virtual vm和MAT的截图都是后续再分析时候截的。 图1 图2 图3 图4 图5 图6 图7 图8 图9 图10 图11 图12 图13 图14","categories":[{"name":"问题处理","slug":"问题处理","permalink":"http://yoursite.com/categories/问题处理/"}],"tags":[{"name":"OOM","slug":"OOM","permalink":"http://yoursite.com/tags/OOM/"},{"name":"virtual vm","slug":"virtual-vm","permalink":"http://yoursite.com/tags/virtual-vm/"},{"name":"MAT","slug":"MAT","permalink":"http://yoursite.com/tags/MAT/"},{"name":"pinpoint","slug":"pinpoint","permalink":"http://yoursite.com/tags/pinpoint/"}],"keywords":[{"name":"问题处理","slug":"问题处理","permalink":"http://yoursite.com/categories/问题处理/"}]},{"title":"使用github pages搭建个人博客","slug":"github-pages-blog","date":"2018-03-14T00:22:36.000Z","updated":"2019-10-17T02:09:56.889Z","comments":true,"path":"2018/03/14/github-pages-blog/","link":"","permalink":"http://yoursite.com/2018/03/14/github-pages-blog/","excerpt":"","text":"一、github pagesgithub pages可以托管静态网站，免空间费，免流量费，值得你拥有。 注册github账号； 注册完成后，右上角-&gt;your profile 可以看到自己注册的github的名字（你的github名称），这个很重要后面中创建blog的repository的时候要用到这个名字 https://github.com/#{your github name} 二、创建repository创建用于托管静态页面的github仓库 Repositories -&gt; New 设置repository name 这个名字一定是自己注册的时候用的名字开头，也就是上面看到的#{your github name}再拼上.github.io 选择主题 设置theme OK， 可以用http://#{your github name}.github.io/ 看你的blog了 添加index.md, 在文件里写上 1234# My github pages blog.我的博客！！！ Hello world 刷新下 http://#{your github name}.github.io/ 就可以看到页面更新了 三、设置ssh为了方便后续将blog clone到本地，修改后push不用每次都敲用户名密码，所以配下ssh 下载git 客户端, 一路next默认安装就可以了。git client下载地址 安装完git后， 然后右键git bash here 1$ ssh-keygen -t rsa -C &quot;你的邮箱&quot; 三次回车后，生成id_rsa和id_rsa.pub文件 123$ cd ~/.ssh$ ls -l $ cat id_rsa.pub 将id_rsa.pub里的内容复制贴到key中，确认ok 然后将刚刚设置的key和本地绑定(中间输入yes) 然后将邮箱和用户名添加到global config， 以便后续提交代码的时候，可以识别到是谁在操作 12$ git config --global user.email &quot;你的邮箱&quot;$ git config --global user.name &quot;你的github名&quot; 最后可以试一下git操作了先clone blog的repository到本地， 然后随便加句话”Let’s GO!!!”, 再push到github上去。 123456$ git clone git@github.com:$&#123;you github name&#125;/$&#123;you github name&#125;.github.io.git$ cd $&#123;you github name&#125;.github.io/$ vi index.md$ git add * $ git commit -m &quot;modify index.md&quot;$ git push ok, 到这里结束了！！！","categories":[{"name":"github 博客","slug":"github-博客","permalink":"http://yoursite.com/categories/github-博客/"}],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"github pages","slug":"github-pages","permalink":"http://yoursite.com/tags/github-pages/"}],"keywords":[{"name":"github 博客","slug":"github-博客","permalink":"http://yoursite.com/categories/github-博客/"}]},{"title":"工具使用-Eclipse常用快捷键","slug":"eclipse_shortcut_key","date":"2018-03-10T00:00:00.000Z","updated":"2019-10-17T11:13:01.739Z","comments":true,"path":"2018/03/10/eclipse_shortcut_key/","link":"","permalink":"http://yoursite.com/2018/03/10/eclipse_shortcut_key/","excerpt":"","text":"快捷键快捷键建议在日常开发中尽量多使用，可以大大提高编写代码效率。多用，快捷键都不用记，会成为手指习惯，用鼠标的场景也会相当少，鼠标用多了手指会酸痛的。 以下是一些常用快捷键的介绍： 注：ctrl+shif+l 所有已经设置的快捷键，可以用这个快捷键查看到 1、代码编写相关快捷键 快捷键 说明 alt+/ 代码提示，这个不用说了，大家都知道 ctrl+1 为错误代码给出纠正方案; 比如抛出异常，调用有非RuntimeException异常声明的方法适合，ctrl+1选择异常处理方式(add throws declaration或者Surround with try/catch)，回车；实现接口，引入接口后，在类上ctrl+1选择add unimplements method, 回车；我常用的是调用一个方法，要将方法返回值设置给本地变量，直接写方法调用，然后ctrl+1, Assign statement to new local variable, 搞定， 也可以使用ctrl+2, l (L的小写)， 但ctrl+2类型的是组合快捷键，需要先按ctrl+2等选择界面出来后，才能选再按l， 比较慢； ctrl+shift+o 导入包，并清理import， 注意可能个别包会导错，有多个需要可选包的时候注意选择正确的包 ctrl+d 删除当前行或者当前选中的内容 ctrl+/ 注释当前行代码， //单行注释 ctrl+shift+/ 注释当前选择内容，/ /块注释 ctrl+shift+f 如果选择代码，则格式化选择代码，如果没选中，格式化整文档 ctrl+3 quick access, 类似sb的goto anything ctrl+alt+↓或者ctrl+alt+↑ 复制当前行或当前选中内容 alt+shift+g 代码生成提示， 默认如getter setter，toString, equals, hashCode等方法的生成没有快捷键绑定，windows-&gt;preference-&gt;general-&gt;keys可以设置 ctrl+空格 补全代码， 如果Java-&gt;Editor-&gt;Content Assist的提示延迟比较小，不用敲这个快捷键也很快出来，但是延迟太小，提示太快对编码也有影响，根据个人习惯自由调整，注意设置中还有triggers for java可以设置成.abcdefghijklmnopqrstuvwxyz，触发更灵敏 shift+enter 在当前行下面另起一个空行，sb快捷键也有，只是快捷键默认是ctrl+enter ctrl+shift+enter 在当前行上面另起一个空行 ctrl+. 或者 , 如果有警告或者错误，可以用这个快捷键来跳转到上一个或者下一个警告或错误 alt+shift+↑或↓或 ← 或 → 选择代码块，按多次↑，可以一直往外选择完整代码块，其实上下左右的箭头都可以用，上扩下缩，左上扩右下扩 ctrl+shift+← 或 → 以单词为单位控制光标跳动 ctrl+shift+↑或↓ 以元素（方法，属性等）为单位控制光标跳动 shift+home或end 选择到行首或选择到行尾 ctrl+shift+home或end 选择到文件头或选择到文件尾 ctrl+shift+Y 转成小写 ctrl+shift+X 转成大写 2、重构快捷键 快捷键 说明 alt+shift+l 抽取成本地变量 alt+shift+m 抽取成方法 alt+shift+r 改名字，所有应用到的地方都会跟着更改 alt+shift+c 图形化的重构方法签名界面 3、源码查看相关快捷键 快捷键 说明 F2 当前光标所在处的代码信息，如果是方法，查看的是方法说明 F3 打开声明处，比如方法定义，类定义，变量声明处等 F4 打开类型关系透视图 ctrl+alt+h 查看方法调用链 ctrl+t 查看类的继承关系，如果在接口方法上使用快捷键，可以直接查看到接口的实现类，点击实现类，可以直接查看到实现方法 ctrl+shift+r 打开资源文件， 一般是查找xml，js之类文件的快捷方式，不需要知道路径，只需要文件名 ctrl+shift+u 在当前文档中查找当前光标所在的属性、变量、方法、类、字符串等在文件中出现的位置，这个快捷键好用，墙裂推荐 ctrl+l 跳转到指定的某一行 ctrl+e 一次打开文件太多了，可以用这个快捷键，输入文件名，打开对应的文件，不能用光标选择 ctrl+shift+e 跟ctrl+e有点类似，需要用光标上下选择 ctrl+page up 或 page down, ctrl+shift+page up 或 page down 这四个快捷键类似，切换打开的文件，如果是遇到收起来的文件，功能和ctrl+e类似，但是多了切换功能 ctrl+shift+p 跳到代码块的开始位置或结束位置 ctrl+g 在工作空间中查找当前光标内容（本地变量，属性，类，方法等）被定义的位置 ctrl+alt+g 在workspace中查找当前选中文本 ctrl+k 向前查找当前选中内容 ctrl+shift+k 向后查找当前选中内容 ctrl+f 查找 ctrl+h 强力查找 4、调试相关快捷键 快捷键 说明 F5 进入被调用方法调试 F6 步进调试 F7 执行当前方法剩余所有内容，并退出，返回到当前方法被调用出继续 F8 不再调试当前断点 F11 调试运行当前类 ctrl+F11 Runy运行 ctrl+alt+b 跳过所有断点 ctrl+shift+b 添加当前行断点 5、其他快捷键收起/展开代码 : 快捷键 说明 ctrl + - 收起当前方法 ctrl + + 展开当前方法 ctrl + shift + / (数字键盘的除号) 收起所有方法 ctrl + shift + * (数字键盘的乘号) 展开所有方法 ####### 编辑窗口 ： 快捷键 说明 esc 关闭弹出窗口 alt+ ← 往前切换打开编辑窗口的历史 alt + → 往后切换打开编辑 窗口的历史 ctrl+w 关闭当前编辑窗口 ctrl+shift+F4 关闭所有编辑窗口 ctrl+m 最大化或最小化当前窗口 其他 ： 快捷键 说明 ctrl+shift+3 commit… ; 如果是被scm管理的代码，会调用提交窗口；比如git的commit","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"eclipse快捷键","slug":"eclipse快捷键","permalink":"http://yoursite.com/tags/eclipse快捷键/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}]},{"title":"工具使用-Eclipse调试Java常用功能介绍","slug":"eclipse_debug_java","date":"2018-03-10T00:00:00.000Z","updated":"2019-10-17T11:13:06.418Z","comments":true,"path":"2018/03/10/eclipse_debug_java/","link":"","permalink":"http://yoursite.com/2018/03/10/eclipse_debug_java/","excerpt":"","text":"调试常用功能介绍日常java开发中实际写代码的时间并不会很多，花在整理思路，代码重构，调试bug会占用很大部分时间。熟练掌握调试工具，了解调试相关技巧，是java开发中减少调试时间，提高效率不可或缺的一部分。使用System.out.println作为调试主要工具的方法，是java初学者对着书本例子敲代码的做法。 一、调试相关的常用窗口调试中最常用的窗口是: 窗口 说明 Debug窗口 主要显示当前线程方法调用栈， 以及代码行数(有调试信息的代码) 断点Breakpoints窗口 =&gt; 断点列表窗口，可以方便增加断点，设置断点条件，删除断点等 变量Variables窗口 =&gt; 显示当前方法的本地变量，非static方法，包含this应用，可以修改变量值 代码编辑窗口 =&gt; 这个不用多说了 输出Console窗口 =&gt; 日志等输出内容，调试时，可以将关注的组件级别设置低一点，以便获得跟多输出信息 另外辅助的窗口有: 窗口 说明 表达式expression窗口 =&gt; 写上自己需要观察的数据的表达式，或者修改变量值 Display窗口 =&gt; 可以在display中执行代码块，输出内容等 大纲Outline窗口 =&gt; 查看当前类的方法，变量等 类型层级Type hierarchy窗口 =&gt; 查看当前所在类的继承层次，包括实现接口，类继承层次 方法调用关系Call hierarchy窗口 =&gt; 查看当前方法被哪些方法调用，调用方法在哪些类中、第几行，可以直接打开对应的方法 搜索结果Search窗口 =&gt; 结合快捷键可以查看变量、方法等在工作空间、项目、工作集中被引用或定义的代码位置 窗口全览： 二、断点类型及断点窗口在调试中可以设置的断点类型有五种： 行断点(line breakpoints)，方法断点(method breakpoints )，观察断点(watch breakpoints-成员变量访问变更)，异常断点(exception breakpoints), 类加载断点(class load breakpoints)。每种断点的设置有些许不一样，可以在断点上右键-&gt;Breakpoint properties进行设置，但一般在断点窗口有快速设置的界面，Breakpoint properties中多了filter, 其实比较鸡肋，用处不大。 断点相关的快捷键： 快捷键 说明 ctrl+shift+b 在光标处大断点/取消断点 ctrl+alt+b 忽略所有断点 Alt+shift+q, b 激活断点窗口 1、行断点： 在方法中的某一行上打断点1.1、1.4。行断点可以设置挂起线程/VM的条件1.3，访问次数1.2。 1.3中的条件是，spring在注册Bean定义(registerBeanDefinition)时，如果是org.springframework.demo.MyBean，就挂起线程，可以开始单步调试了。 对于命中次数(hit count)1.2的使用，一般是在循环中，第N个对象的处理有问题，设置hit count = N， 重调试时，可以方便到达需要调试的循环次数时，停下来调试。 2、方法断点：在方法上打断点2.1、2.2。方法断点的好处是可以从方法方法进入或者退出时2.3，停下来调试，类似行断点，而且只有行断点和方法断点有条件和访问次数的设置功能。 但是方法断点还有另外一个好处，如果代码编译时，指定不携带调试信息，行断点是不起作用的，只能打方法断点。 有兴趣的可以通过A1将Add line number… 前的勾去掉， 调试下看看。 3、观察断点： 在成员变量上打的断点3.1、3.3。只有对象成员变量有效果，静态成员变量不起作用。 可以设置变量被访问或者设置的时候挂起线程/VM 3.2，也就是类似3.4的所有对成员变量的访问或者设置的方法都会被监控到4、异常断点： 异常断点可以通过4.6添加，或者点击日志信息中输出的异常类信息添加。 异常断点4.1，系统发生异常时，在被捕获异常的抛出位置处或者程序未捕获的异常抛出处4.2、4.4, 挂起线程/VM， 也可以指定是否包括异常的子类也被检测4.3、4.5。 另外除了以上正常设置的异常挂起，从java-&gt;debug中可以设置挂起执行，主要有下面两个： 1、是否在发生全局未捕获时挂起(suspend execution on uncaught exceptions)，调试时，老是有异常挂起影响调试，但是没有设置异常断点的情况，就可以勾选掉这个选项；2、是否在编译错误时挂起，一般在边调试边改代码时会发生这种情况； 另外要提一个的是有main方法启动的应用，可以在调试配置中勾选stop in main A3, 程序进入时，会挂起线程，等待调试。 5、类加载断点: 在类名上打的断点5.1。接口上是打不了类加载断点的，但是抽象类是可以的，只是在调试的时候，断点不会明显进入classloader中，单步进入知会进入到子类的构造方法中，非抽象类在挂起线程后单步进入就会到classloader中（如果没有filter过滤掉的话）5.3。类加载断点不管是打在抽象或者非抽象类上，都会在类第一次加载或者第一个子类第一次被加载时，挂起线程/VM 5.2。 三、Debug窗口、代码窗口，快捷键打完断点进入调试阶段，调试过程中最主要的就是调试窗口和代码窗口， 调试窗口和代码窗口的右键菜单、使用的快捷键以及达到的效果都值得深入了解； Debug窗口右键菜单及快捷键：如A6所示。代码窗口右键菜单及快捷键：如A7所示。 下面将按照功能，结合A6、A7一起说明： 1、调试执行： 标记 功能 快捷键 描述 6.4 Step Info F5 -&gt; 单步进入(如果有方法调用，将进入调用方法中进行调试); 6.4 Step Over F6 -&gt; 单步跳过(不进入行的任何方法调用中，直接执行完当前代码行，并跳到下一行); 6.4 Step Return F7 -&gt; 单步返回(执行完当前方法，并从调用栈中弹出当前方法，返回当前方法被调用处)； 6.5 Resume F8 -&gt; 恢复正常执行(直到遇到下一个断点); 7.4 Run to Line Ctrl+R -&gt; 执行到当前行(将忽略中间所有断点，执行到当前光标所在行); 6.3 Drop To Frame 无 -&gt; 回退到指定方法开始处执行，这个功能相当赞。在方法调用栈上的某个方法右键，选择Drop To Frame就可以从该方法的开始处执行 比如重新执行本方法，可以在本方法上用Drop To Frame，将从本方法的第一行重新执行。当然对于有副作用的方法，比如数据库操作，更改传入参数的对象内容等操作可能重新执行就再是你想要的内容了。 6.1+6.2 Copy Stack 无 -&gt; 拷贝当前线程栈信息 如果在调试时，需要排除一些类、包等不需要进入调试，可以使用Edit Step Filters设置。 A6的properties： Java进程启动相关信息，包括控制台启动参数，环境参数等。如果参数启动参数有问题可以先看看这里的实际启动参数是不是有误。另外还可以查看虚拟机支持调试的相关选项。 2、数据查看 标记 功能 快捷键 描述 7.4 Inspect ctrl+shift+i -&gt; 察看选择的变量、表达式的值或执行结果, 再次按ctrl+shift+i可以将当前表达式或值添加到Expressions窗口中查看; 7.4 Display ctrl+shift+d -&gt; 显示选择的变量、表达式的值或执行结果, 再次按ctrl+shift+d可以将当前表达式或值添加到Display窗口中显示; 7.4 Execute ctrl+u -&gt; 执行选择表达式; 7.4 Run to Line ctrl+r -&gt; 执行到当前行(将忽略中间所有断点，执行到当前光标所在行); 7.3 All Instances ctrl+shift+n -&gt; 查看选择的类的所有对象，这个功能超赞； 7.3 Instance Count 无 -&gt; 查看选择的类的所有对象个数； 7.4 Watch 无 -&gt; 添加当前变量、表达式到Expressions窗口中； 四、调试时窗口1、Display窗口A8 在Display窗口中，可以执行代码之外的任何合理的语句，也可以使用Inspect， Display, Execute这些方式查看或者执行语句——8.1。比如， a、输入com.alibaba.fastjson.JSON.toJSONString(registry, true); 并选择这一行代码，ctrl+shift+d，可以执行这行代码并在Display窗口中输出结果——8.2。b、当然也可以改变当前代码的变量值，比如输入beanName = “myBeanX”; 选择这行代码，用Inspect， Display, Execute这几种方式都可以执行这行代码。c、也可以输入System.out.println(com.alibaba.fastjson.JSON.toJSONString(registry, true)); 执行就会在console窗口输出结果。 2、Variables窗口A9 在Variable窗口中可以看到当前方法的本地变量值8.3，非静态方法会有this表示对象自己，也可以查看本地变量相应的属性8.4， 8.5的功能可以让集合类型对象中的数据显示容易看点。这个窗口除了察看变量的功能之外，还可以直接在Value列修改变量值或对象属性。 3、Expression窗口A10 Expression窗口的功能主要是用来察看变量之外的表达式的结果，执行固定表达式等功能。比如察看变量definitionHolder中的属性beanDefinitionHolder, 直接将definitionHolder.getBeanDefinition()加入到Expressions窗口8.6， 8.7。 五、代码查看辅助窗口1、代码窗口： 标记 功能 快捷键 描述 11.1~11.5 quick type hierarchy ctrl+t 查看当前类、接口的继承层次， 默认进入时，显示继承/实现当前类/方法的子类，子接口11.1；再次ctrl+t，将显示当前类、接口继承/实现的超类/接口11.2；调试时，经常用该功能，在接口或抽象类的方法调用处11.3，ctrl+t察看实现类11.4，直接导航到对应的实现方法中11.5。 quick outline ctrl+o 查看当前类的大纲，包括方法，属性等内容； 用处不大； open declarations F3 查看变量、属性、方法定义的地方 2、Call Hierarchy窗口: 标记 功能 快捷键 描述 12.1~12.2 open call hierarchy ctrl+alt+h 查看方法被调用层次， 可以看当前方法被调用的地方12.1，或者当前方法调用了其他类的方法12.2 3、Type Hierarchy窗口： 标记 功能 快捷键 描述 13.1~13.4 open type hierarchy F4 查看继承层次， 可以查看类的继承层次，包括子类父类13.1， 或者类实现的接口继承层次13.2，还会根据选择的类/接口，在右边显示该类的大纲13.3、 13.4； 13.3可以选择是否显示父类/父接口的属性、方法等 4、Search 窗口： 标记 功能 快捷键 描述 14.1 declarations ctrl+g 相同的方法签名在工作空间中及第三方jar包中被定义的位置14.1 14.2 references ctrl+shif+g 当前选中的变量、属性、方法在工作空间中及第三方jar包中被引用的位置14.2 14.3 ctrl+shift+u 查看变量、属性 、方法在当前类中出现的地方14.3 14.4 implements 查看实现当前接口的类14.8 14.4~14.7 显示方式 可以选择不同的显示方式，具体看图","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"eclipse调试","slug":"eclipse调试","permalink":"http://yoursite.com/tags/eclipse调试/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}]},{"title":"Java基础--Java SE 5增加的特性--语法篇（一）","slug":"java_base_jdk5_new_feature_language_1","date":"2018-03-10T00:00:00.000Z","updated":"2019-10-17T11:12:51.740Z","comments":true,"path":"2018/03/10/java_base_jdk5_new_feature_language_1/","link":"","permalink":"http://yoursite.com/2018/03/10/java_base_jdk5_new_feature_language_1/","excerpt":"","text":"为什么是Java SE 5？目前已经到了JDK-8u74了，JDK7的主版本已经于2015年4月停止公开更新。 那为什么还要来说Java/JDK5呢？ Java SE在1.4（2002）趋于成熟，随着越来越多应用于开发企业应用，许多框架诞生于这个时期或走向成熟。Java SE 5.0的发布（2004）在语法层面增加了很多特性，让开发更高效，代码更整洁。 自动装箱/拆箱、泛型、注解、for循环增强、枚举、可变参数等新特性让你的小手指少敲了不少代码，可以写更优雅的实现; API提供并发库大大减少并发编程的难度; 虚拟机层面改进了内存模型，增加虚拟机监控和管理相关的api和工具等等。 但是，语法层面的改变对应于JVM却没有多大变化，只是编译器在编译字节码时偷偷做了手脚。所以我们应该了解下到底编译器干了啥坏事，有助于写更合理的代码，少踩坑，掉陷阱里也得知道怎么掉的。 另外原因，目前从各种各样的项目代码看，其实多数开发人员常用的还是Java SE 5.0 的特性，甚至习惯用Java SE 1.4及以前的语法特性。学java也有几年了，许多特性也知道个一二，但是要写下来，还是得查阅不少文章，很多东西欠缺完整性和系统性。码农写文章（更合理说是整理资料）也是一个学习的过程。 学习一门语言，一旦实际应用于实际开发中，了解背后的原理和理念，深入了解语言的特点，有好处没坏处。 注：javac XXXXX.java 编译命令 javap -c XXXXX 反编译命令 -c 反编译 -s 输出内部类型签名 需要看方法签名时 要加上这个参数 -v 输出附加信息 会输出比较多信息 包括常量表 line number table 等信息， 但没有-s的输出内容 一、自动装箱/拆箱1、包装类型（存在于Java 1.5之前）Java中，类型分成两大类，基本类型（Primitive Type）和引用类型(Reference Type)。基本类型是内定的，有确定的取值范围，值占有确定的内存空间。 有八大基本类型，分成两个浮点类型（float、double），五个整型(byte, short, int, long，char), 一个布尔型(boolean)。没看错char也是整型，在语言规范中说明，char是一个16bit无符号整形，用来表示一个UTF-16编码的单元(在Java5中对应Unicode4.0，Java8中对应Unicode6.2)。 基本类型的值不是对象，最基本的对象(Object)方法(toString, hashCode, getClass, equals等)也不能调用。 为了把基本类型当引用类型来用，具备对象的特质，JDK中定义了各种基本类型相对应的包装类。所谓装箱，就是将基本类型的值包装成(转换-conversion)对应的包装类型的对象，拆箱，就是讲包装类型的对象，转换成基本类型的值。 装箱和拆箱：12Integer i = 100;int j = new Integer(250); 基本类型 大小 数值范围 包装类型 默认值 boolean — true, false Boolean false byte 1字节(8bit) -2^7 – 2^7-1 Byte 0 char 2字节(16bit) \\u0000–\\uffff Character \\u0000 short 2字节(16bit) -2^15 – 2^15-1 Short 0 int 4字节(32bit) -2^31 – 2^31-1 Integer 0 long 8字节(64bit) -2^63 – 2^63-1 Long 0 float 4字节(32bit) IEEE754 Float 0.0f double 8字节(64bit) IEEE754 Double 0.0d 2、自动装箱/拆箱背后前面说了，语法特性的改变并没改变JVM的实现方式，那么我们可以看看背后编译器到底干了啥事情。下面代码和编译后的反编译结果： 1234public void boxUnBox()&#123; Integer i = 100; int j = new Integer(250);&#125; 反编译结果可以看到，以上代码实际等同于以下代码的编译结果：123456public void boxUnBox()&#123; Integer i = Integer. valueOf(100); Integer t = new Integer(250); int j = t .intValue();&#125; 八大基本类型的装箱操作都调用的是valueOf方法，拆箱操作调用各自赌赢的xxxValue()方法，有兴趣可以试试。 3、注意==比较的陷阱在java中，计算类型的运算符，先来看下比较的代码编译结果：123456789public void boxUnBoxCMP()&#123; Integer i = 100; int j = new Integer(250); if(j == i )&#123;&#125; Integer h = new Integer(100); Integer k = new Integer(100); if(h == k )&#123;&#125; &#125; ==第一个红框==是if(j == i ) 的反编译代码从上面的反编译结果可以看出，包装类型的单目运算符计算其实是需要通过拆箱=&gt;计算=&gt;装箱实现的，而双目运算符的运算也是需要将包装类型转换成基本类型，然后再参与运算。 但是，== 的比较要牢记它的本质，如果==比较两边都是引用类型，那么比较的是引用地址，如果其中一边是基本类型，那么非引用类型的值将转换成基本类型再做比较。==第二个红框==中是引用比较，没有转换。 4、Cache带来的坑我们看看自动装箱的valueOf的代码吧12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache. high) return IntegerCache.cache[i + (-IntegerCache. low)]; return new Integer(i);&#125; 一眼就可以看到IntegerCache这个玩意，完整代码（JDK1.8的代码）如下：1234567891011121314151617181920212223242526272829303132private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; // 根据配置获取缓存最大值，最大值配置范围 127 &lt; h &lt; Integer.MAX_VALUE-129 String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt( integerCacheHighPropValue); i = Math. max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math. min(i, Integer.MAX_VALUE - (- low) -1); &#125; catch( NumberFormatException nfe ) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h ; cache = new Integer[(high - low) + 1];// 也许有人会疑惑为什么会有个+1，其实就是0这个数占了个坑 int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k ] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache. high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; IntegerCache的意思就是将low到high的值先缓存起来，low恒定是-128， high默认是127，可以配置成127&lt;= high &lt;= Interger.MAX_VALUE-129注意缓存的是Integer对象，所以是引用对象。既然是引用对象，那么==的比较就会有问题了。 1234567891011 public static void trap()&#123; Integer i = 100; Integer k = 100; if(i == k )&#123;System.out.println( \"i == k\");&#125; Integer j = 500; Integer h = 500; if(j == h )&#123;System.out.println( \"j == h\");&#125;else &#123; System.out.println(\"j != h\" );&#125; &#125; 输出结果是什么呢？i == kj != h 因为i和k都是从IntegerCache中取得的缓存对象，引用是一样的，j和h没有缓存，必须valueOf必须重新new一个Integer对象，所以引用是不等的。 类型Byte、Short、Long和Integer类似，只是没有可配置的最大缓存值，Byte所有值都被缓存了，所以不存在==的坑。Character缓存的是0~127。Float和Double没有缓冲，也没办法缓存。 5、建议 不会参与运算的用包装， 比如数据库自增的记录ID，用Long类型 参与运算的，如果计算复杂，尽量先转成基本类型，计算后再转回对应的包装类对象；特别是频繁的单目运算符，如循环中的自增自减 参与比较，注意包装类的cache坑 记得所有集合中只能存对象类型，基本类型都是经过装箱/拆箱的 举个不好的例子吧：1234567891011 public static Long bad(List&lt;Integer&gt; list)&#123; Long sum = 0L; for(Integer i : list )&#123; if(i % 2 == 0 )&#123; sum += i; &#125; else &#123; sum += i * 2; &#125; &#125; return sum ;&#125; 有兴趣的童鞋可以反编译看下，类似于以下代码完成的事情：12345678910111213141516171819 public static Long badOrigin(List&lt;Integer&gt; list)&#123; Long sum = Long. valueOf(0L); Iterator&lt;Integer&gt; it = list.iterator(); Integer value = null; long sumTmp = 0L; while(it .hasNext())&#123; value = it.next(); if(value .intValue() % 2 == 0)&#123; sumTmp = sum.longValue(); sumTmp = sumTmp+ value.intValue(); sum = Long. valueOf(sumTmp); &#125; else &#123; sumTmp = sum.longValue(); sumTmp = sumTmp+ value.intValue()*2; sum = Long. valueOf(sumTmp); &#125; &#125; return sum ;&#125; 按照建议来，可以改成以下代码：12345678910111213 public static Long good(List &lt;Integer&gt; list )&#123; long sum = 0L; int value = 0; for(Integer i : list )&#123; value = i.intValue(); if(value % 2 == 0 )&#123; sum += value; &#125; else &#123; sum += value * 2; &#125; &#125; return sum ;&#125; 以上反编译下看看字节码，是不是清爽多了^^ 二、for循环增强for循环增强也是1.5里的一个语法糖，让大家写for循环更加便利，再加上IDE的代码模板，非常方便 1、先看看List的for循环增强怎么写：12345 public void iteratorForeach()&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String str : list ) &#123; &#125;&#125; 反编译结果如下，可以看出，其实就是调用Iterable接口的iterator方法，获得一个迭代器(Iterator), 利用迭代器进行遍历所有数据。从这里也可以推出，只要实现Iterable接口的类型，都可以在for循环增强中使用： 比如自己实现一个只有add方法，只能通过iterator遍历的List： 1234567891011121314151617181920212223242526272829 public void myListForeach()&#123; MyList&lt;String&gt; myList = new MyList&lt;&gt;(); for (String str : myList ) &#123; &#125; &#125; public static class MyList&lt;V&gt; implements Iterable&lt;V&gt;&#123; private List&lt;V&gt; datas = new ArrayList&lt;&gt;(); public void add(V data )&#123; datas.add( data); &#125; @Override public Iterator&lt;V&gt; iterator() &#123; final Iterator&lt;V&gt; it = datas .iterator(); return new Iterator&lt;V&gt;() &#123; @Override public boolean hasNext() &#123; return it .hasNext(); &#125; @Override public V next() &#123; return it .next(); &#125; &#125;; &#125; &#125; 2、再看看数组类型的for循环增强怎么写：123456789101112 public void arrayForeach()&#123; String[] strs = new String[10]; for (String str : strs ) &#123; &#125; System. out.println(); String str = null ; for(int i = 0; i &lt; strs .length ; i ++)&#123; //传统for循环写法 str = strs[ i]; &#125;&#125; 跟传统for循环相比，数组的for增强循环更加简洁，从反编译代码中也可以看出，用到的指令序列基本上是一样的。 3、不适应的地方这么好的东西什么情况下用不了呢？ 主要是for增强循环中没能得到下标也没能得到iterator对象引用导致的。第一种是数组或者List集合类型，需要用到下标的情况；第二种是需要调用到Iterator接口的remove方法的情况； 三、可变参数Java SE 5.0中增加了可变参数特性，对于以往用数组表示的参数可以调整到最后一个参数，作为可变参数定义，调用方省去显示创建数组，可空数组可以直接可以省略： 12345678910public static void varargs(String s, String... ss) &#123;&#125;public static void main(String[] args) &#123; varargs(\"aaa\" ); varargs(\"aaa\" , \"bbb\" ); varargs(\"aaa\" , \"bbb\" , \"ccc\" , \"ddd\" ); varargs(\"\", null) ; varargs(\"aaa\" , new String[]&#123;\"abc\", \"ccc\", \"ddd\" &#125;);&#125; 可变参数背后编译器也是创建一个数组来传递参数的，可以方编译以上代码， varargs的方法签名中第二个参数就是一个string数组： ==注意事项：== 不能有多个可变参数，并且只能是最后一个参数； 因为可变参数是由数组实现的，调用方忽略可变参数时，可变参数为空数组；但是既然是数组，就可以设置成null，所以要注意空判断； 如果被调用的方法，既匹配了可变参数方法，有匹配了固定参数方法，固定参数方法将被调用； 尽量避免可变参数方法的重载（overload）: 可变参数类型与前一个参数的类型一样时，与只有可变参数类型方法重载冲突，会导致调用不明确； 可变参数类型不同，但可变参数为空时，可以省略，或者设置成null，都会导致被调用方法不明确； 可变参数类型是基本类型或包装类型，重载会因为自动装箱/拆箱导致调用不明确 override的方法参数类型和形式必须一致，不能将可变参数改成数组，虽然背后实现是一样的； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/**不能有多个可变参数，并且只能是最后一个参数**/public static void varargs10(Object ... objs, String abc)&#123; //编译出错&#125;public static void varargs11(String abc, Object ... objs)&#123;&#125;/**因为可变参数是由数组实现的，调用方忽略可变参数时，可变参数为长度为0的数组；但是既然是数组，就可以设置成null，所以要注意null判断；**/public static void varargs2Test()&#123; varargs2(); varargs2(null); //NullPointerException&#125; public static void varargs2(String...strs)&#123; //strs 可能为null, 应该做 strs是否为空的判断 for (String str : strs ) &#123; &#125;&#125; /**如果被调用的方法，既匹配了可变参数方法，有匹配了固定参数方法，固定参数方法将被调用；**/public static void varargs3Test()&#123; varargs3(11, 22); //varargs30&#125;public static void varargs3(int i, int j )&#123; System. out.println(\"varargs30\" );&#125;public static void varargs3(int i , int... arr)&#123; System. out.println(\"varargs31\" );&#125; /**可变参数类型与前一个参数的类型一样时，与只有可变参数类型方法重载冲突，会导致调用不明确；**/public static void varargs4Test()&#123; varargs4(\"abc\" , \"def\" , \"ijk\" ); //编译出错&#125;public static void varargs4(String...strs)&#123;&#125;public static void varargs4(String str, String... strs)&#123;&#125; /**可变参数类型不同，但可变参数为空时，可以省略，或者设置成null，都会导致被调用方法不明确；**/public static void varargs5Test()&#123; varargs5(); //编译出错 varargs5(\"abc\" , null); //编译出错&#125;public static void varargs5(String str, String... strs)&#123;&#125;public static void varargs5(String str, Integer... datas)&#123;&#125; /**可变参数类型是基本类型或包装类型，重载会因为自动装箱/拆箱导致调用不明确**/public static void varargs6Test()&#123; varargs6(\"abc\" , 1, 2, 3); //编译出错&#125;public static void varargs6(String str, int... datas)&#123;&#125;public static void varargs6(String str, Integer... datas)&#123;&#125; /**override的方法参数类型和形式必须一致，不能将可变参数改成数组，虽然背后实现是一样的**/public static void varargs7Test()&#123; Sub sub = new Sub(); Base base = sub; base.varargs7( \"abc\", \"def\" ); base.varargs7(); sub.varargs7(); //编译错误 sub.varargs7(\"abc\" , \"def\" ); //编译错误&#125; public static interface Base &#123; public void varargs7(String...strs );&#125; public static class Sub implements Base&#123; @Override public void varargs7(String[] strs) &#123; System. out.println(\"varargs7\" ); &#125;&#125; 四、StringBuilder和字符串+(非1.5特性，顺便提一下而已)JDK 5.0中增加了StringBuilder, 基本上和StringBuffer一样，但去掉了所有synchronized同步关键字。性能上StringBuilder优于StringBuffer， 所以非并发情况下使用StringBuilder没商量。 Java中对象没有参与运算符运算的可能，也没有提供像C++那样重载运算符语法支持，不要被String的+操作欺骗了。Java1.4中，字符串的+操作在编译器生成的字节码可以看到使用的是StringBuffer进行append，Java5.0中，+操作改成StringBuilder的append: 123public static void sbTest(String s1, String s2)&#123; String str = s1 +s2 ;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}]}]}