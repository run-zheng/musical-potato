<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="zheng run(郑润)的个人博客."><meta name="keywords" content="java"><title>【译】javassist使用指南三(ClassLoader) | ZhengRun's Blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【译】javassist使用指南三(ClassLoader)</h1><a id="logo" href="/.">ZhengRun's Blog</a><p class="description">郑润的个人博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">【译】javassist使用指南三(ClassLoader)</h1><div class="post-meta"><a href="/2019/11/15/【译】javassist使用指南三/#comments" class="comment-count"></a><p><span class="date">Nov 15, 2019</span><span><a href="/categories/javassist/" class="category">javassist</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="三、ClassLoader"><a href="#三、ClassLoader" class="headerlink" title="三、ClassLoader"></a>三、ClassLoader</h2><p>如果事先知道哪些类需要修改，最简单的修改类方式如下： </p>
<ul>
<li>1、 通过调用ClassPool.get()方法获取一个CtClass对象</li>
<li>2、 修改它</li>
<li>3、 调用CtClass对象的writeFile()或toBytecode()方法获取修改后的类文件 </li>
</ul>
<p>如果在类加载的时候要确定一个类是否被修改，用户应该让Javassist和类加载器一起工作。Javassist可以通类加载器一起工作，在加载类的时候修改类字节码。用户可以定义自己的ClassLoader，也可以使用Javassist提供的ClassLoader。 </p>
<h3 id="3-1-CtClass类的toClass方法"><a href="#3-1-CtClass类的toClass方法" class="headerlink" title="3.1 CtClass类的toClass方法"></a>3.1 CtClass类的toClass方法</h3><p> CtClass提供了一个便捷的方法toClass(), 这个方法要求使用当前线程的上下文类加载器，加载CtClass对应的类。 调用该方法， 调用者必须拥有响应的权限；否则，会抛出一个SecurityException异常。 </p>
<p> 以下代码是怎么使用toClass(): </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"org.demo.Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToClass</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    ClassPool cp = ClassPool.getDefault();</span><br><span class="line">    CtClass cc = cp.get(<span class="string">"org.demo.Hello"</span>);</span><br><span class="line">    CtMethod m = cc.getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">    m.insertBefore(<span class="string">"&#123; System.out.println(\"org.demo.Hello.say()\");&#125;"</span>);</span><br><span class="line">    Class c = cc.toClass();</span><br><span class="line">    Hello h = (Hello)c.newInstance();</span><br><span class="line">    h.say();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 </span></span><br><span class="line">org.demo.Hello.say()</span><br><span class="line">org.demo.Hello</span><br></pre></td></tr></table></figure>
<p>Test.main()方法在Hello类的say()方法体中插入了一个println()方法的调用。然后创建从被修改过的Hello类创建一个实例对象，然后调用该对象的say()方法。 </p>
<p>注意，上面代码的前提是Hello类在toClass()前，未被类加载器加载。否则，JVM在toClass()调用修改Hello类前，将加载原来的Hello类。不然的话，尝试加载修改后的Hello类将会报LinkageError错误。比如，下列例子Test的main方法将会抛异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Hello orig = <span class="keyword">new</span> Hello(); </span><br><span class="line">    ClassPool cp = ClassPool.getDefault(); </span><br><span class="line">    CtClass cc = cp.get(<span class="string">"Hello"</span>); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，原始的Hello类在main的第一行已经被加载，因为ClassLoader无法同时加载两个不同版本的Hello类，因此在调用toClass()方法时，将抛出异常。 </p>
<p>如果以上程序运行在JBoss或Tomcat等应用服务器，toClass()方法用到的上下文类加载器可能与预期的不一致。在这种情况下，你可能会看到抛出ClassClassException异常。为了避免这种异常，你必须提供一个合适的类加载器给toClass()。<br>比如，如果bean是会话bean对象，那么以下代码将争取执行： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... </span><br><span class="line">Class c = cc.toClass(bean.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>
<p>你需要提供一个ClassLoader给toClass()方法，这个ClassLoader是用来加载你的程序的类加载器（比如上面例子，Bean对象的加载器) 。</p>
<p>toClass()是一个便捷方法。如果你要更加复杂的功能，你必须编写自己的ClassLoader。 </p>
<h3 id="3-2-Java中的类加载机制"><a href="#3-2-Java中的类加载机制" class="headerlink" title="3.2 Java中的类加载机制"></a>3.2 Java中的类加载机制</h3><p>在Java中，可以同时存在多个类加载器，每个加载器创建自己的命名空间。不同的类加载器可以以相同的类名加载不同的类文件。以这种方式加载的两个类被识别成不同的两个类。这种特性运行我们在一个JVM中运行多个程序，即使这些程序以相同的类名加载了不同的类文件。 </p>
<blockquote>
<p>注：JVM不允许动态重新加载一个类。一旦一个类被一个加载器加载，运行时不能够重新加载这个类的修改过的版本。<br>因此，类被加载后，你不能够修改类的定义。但是，JPDA(Java Platform Debugger Architecture)技术提供了受限制的在运行时加载一个类的能力。 可以参考<a href="http://www.javassist.org/tutorial/tutorial.html#hotswap" target="_blank" rel="noopener">Section 3.6</a></p>
</blockquote>
<p>如果一个类文件被两个不同的类加载器加载，JVM创建两个名字相同、定义也相同的不同类对象。两个类被（JVM）认为是不一样的。因为两个类被被认为是不一样的，一个类的实例对象不能赋值给另外一个类的变量。两个类之间的转换操作会失败并且抛出ClassCastException异常。 </p>
<p>如下例所示，以下代码片段抛出一个异常： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader myLoader = <span class="keyword">new</span> MyClassLoader(); </span><br><span class="line">Class clazz = myLoader.loadClass(<span class="string">"Box"</span>); </span><br><span class="line">Object obj = <span class="class"><span class="keyword">class</span>.<span class="title">newInstance</span>()</span>; </span><br><span class="line">Box b = (Box)obj;</span><br></pre></td></tr></table></figure>
<p>类Box被两个ClassLoader加载。假设一个类加载器CL加载一个类包含该代码片段。这段代码引用MyClassLoader, Class, Object和Box, CL也加载这些类（除非它委托给其他ClassLoader加载）。因此，变量b的类型是Box类，被CL加载。另外一方面，myLoader也加载了Box类。obj对象是一个被myLoader加载的Box类的实例。因此，因为变量obj的类和变量b的类是两个不同版本的Box类， 最后一个语句会抛出ClassCastException异常。 </p>
<p>多个类加载器会形成树形结构。除了bootstrap类加载器之外， 每个类加载器会有一个parent类加载器，父加载器通常用来加载子加载器。由于可以沿着类加载器的树形层次结构，委托加载类的请求， 因此可以一个类可以被一个类加载器加载，但是这个类加载器并不是你直接发起加载请求的类加载器。因此，被请求加载类C的类加载器，可能与真正加载C类的加载器是不一样的。为了区分，我们将前一个加载器叫C的起始加载器，后一个加载器叫C的真实加载器。 </p>
<p>除此之外，如果一个类加载器接收请求加载类C（C的起始加载器），将请求委托给父加载器PL，那么类加载器CL将不会被请求去加载任何类C定义中引用到的类。CL不是这些类的起始加载器。相反的，CL的父类加载器将作为他们（C类定义中引用的类）的起始加载器，并且加载他们。类C定义中引用的其他类，将会被C的真实加载器加载。 </p>
<p>为了理解这种机制，让我们看看以下例子： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">Point</span> </span>&#123; <span class="comment">// loaded by PL </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123; <span class="comment">// the initiator is L but the real loader is PL </span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> upperLeft.getX(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123; <span class="comment">// loaded by a class loader L </span></span><br><span class="line">    <span class="keyword">private</span> Box box; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> box.getBaseX(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设类Window被一个类加载器L加载。类Window的起始加载器和真实加载器都是L。由于Window的定义中引用Box，JVM将请求L加载Box。这里假设L委托该任务给父加载器PL。Box的起始加载器是L，但是真实加载器是PL。在这个案例中，Point的起始加载器不是L，而是PL，因为它是Box的真实加载器。因此L并没有被请求去加载Point类。 </p>
<p>接下来，我们考虑下一下稍微改动后的版本： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">Point</span> </span>&#123; <span class="comment">// loaded by PL </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123; <span class="comment">// the initiator is L but the real loader is PL </span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123; <span class="comment">// loaded by a class loader L </span></span><br><span class="line">    <span class="keyword">private</span> Box box; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">widthIs</span><span class="params">(<span class="keyword">int</span> w )</span></span>&#123;</span><br><span class="line">        Point p = box.getSize(); </span><br><span class="line">        <span class="keyword">return</span> w == p.getX(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，Window的类定义中也引用了Point。在这个案例中， 类加载器L也必须将Point的类加载请求委托给PL。你必须避免两个加载器重复加载相同的类。两个类加载器中，一个类加载器必须委托两位一个去加载。 </p>
<p>如果加载器L没有委托给PL加载Point，widthIs方法将抛出一个ClassCastException异常。因为Box的真实加载器是PL，Box中引用的Point也是由PL加载。因此，getSize()返回值是一个由PL加载的Point实例对象，而widthIs()方法中p变量引用的Point是由L加载。JVM认为他们是不同的类型，因此抛出一个异常，因为类型不匹配。 </p>
<p>这种行为比较绕但确实必要的。 如下语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = box.getSize();</span><br></pre></td></tr></table></figure>
<p>没有抛出异常，那么Window的代码可以破坏Point对象的封装。比如， 由PL加载的Point的属性是私有的。但是，如下定义， Window类可以直接通过由L加载器加载的Point的x属性获得值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y ; <span class="comment">//not private </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x ; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的关于类加载器的详情，可以参考一下paper：</p>
<blockquote>
<p>Sheng Liang and Gilad Bracha, “Dynamic Class Loading in the Java Virtual Machine”,<br>  ACM OOPSLA’98, pp.36-44, 1998.</p>
</blockquote>
<h3 id="3-3-使用javassist-Loader"><a href="#3-3-使用javassist-Loader" class="headerlink" title="3.3 使用javassist.Loader"></a>3.3 使用javassist.Loader</h3><p>  Javassist提供了一个类加载器： javassist.Loader。这个类加载器使用一个javassist.ClassPool读取类文件。 </p>
<p>  比如， javassist.Loader可以用来加载经过Javassist修改的特定类： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassit.*; </span><br><span class="line"><span class="keyword">import</span> test.Rectangle; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">        Loader cl = <span class="keyword">new</span> Loader(pool); </span><br><span class="line">        CtClass ct = pool.get(<span class="string">"test.Rectangle"</span>); </span><br><span class="line">        ct.setSuperclass(pool.get(<span class="string">"test.Point"</span>)); </span><br><span class="line">        </span><br><span class="line">        Class c = cl.loadClass(<span class="string">"test.Rectangle"</span>); </span><br><span class="line">        Object rect = c.newInstance(); </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码修改了类test.Rectangle。test.Rectangle的父类设置成test.Point类。然后程序加载修改过的类，创建test.Rectangle类的新的对象。 </p>
<p>如果用户想要修改一个已经被加载过的类， 可以为javassist.Loader加入一个是事件监听器。事件监听器将会在Loader加载器加载一个类的时候被通知到。类加载器必须实现以下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String className)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>方法start()将会在一个监听器被加入到javassist.Loader对象后，由javassist.Loader的addTranslator()触发调用。onLoad()方法在javassist.Loader加载一个类前被调用。onLoad()方法可以修改已经加载的类的定义。 </p>
<p>比如，以下监听器在类被加载前，更改所有类成public。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTranslator</span> <span class="keyword">implements</span> <span class="title">Translator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String className)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>&#123;</span><br><span class="line">        CtClass cc = pool.get(className); </span><br><span class="line">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，不能在onLoad()方法中调用toBytecode()、writeFile()，因为javassist.Loader在获取类文件的时候，会调用这些方法。 </p>
<p>要运行使用MyTranslator对象的应用MyApp类，如下编写主类： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Translator t = <span class="keyword">new</span> MyTranslator(); </span><br><span class="line">        ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">        Loader cl = <span class="keyword">new</span> Loader(); </span><br><span class="line">        cl.addTranslator(pool, t); </span><br><span class="line">        cl.run(<span class="string">"MyApp"</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行改程序，需要如下命令： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% java Main2 arg1 arg2 ...</span><br></pre></td></tr></table></figure>
<p>类MyApp和其他应用类将被MyTranslator转换。 </p>
<p>注意，类似MyApp的应用类无法访问加载类，如果Main2、MyTranslator和ClassPool, 因为他们是另外的类加载器加载的。这些应用类是由javassist.Loader加载器加载的， 而其他类如Main2等，是由默认加载器加载的。 </p>
<p>javassist.Loader类查找类的顺序与java.lang.ClassLoader不一样。ClassLoader首先委托加载操作给父加载器，无法加载时，才尝试自己加载类。另外一方面，javassist.Loader先尝试加载类，无法加载再委托父加载器加载。在以下情况下， 它委托父加载器加载： </p>
<ul>
<li>调用ClassPool对象的get()方法时，无法找到要加载的类</li>
<li>通过delegateLoadingOf()方法指定加载的</li>
</ul>
<p>将被委托给父类加载器加载。 </p>
<p>这个查找顺序允许加载已经被Javassist修改过的类。但是，它在因为某些原因无法找到已经被修改过的类是，会委托父类加载器加载。一旦一个类被父加载器加载，其他类定义中引用的类也将由父类加载器加载，因此他们不会被修改。<br>之前的例子中，所有C类应用的类会由C的真实加载器加载。如果你的程序无法加载一个修改过的类，你应该确认下是否类所引用的所有类是否都是由javassist.Loader加载。 </p>
<h3 id="3-4-编写一个类加载器"><a href="#3-4-编写一个类加载器" class="headerlink" title="3.4 编写一个类加载器"></a>3.4 编写一个类加载器</h3><p>编写一个使用Javassit的类加载器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.CannotCompileException;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.NotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args )</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        SampleLoader s = <span class="keyword">new</span> SampleLoader();</span><br><span class="line">        Class c = s.loadClass(<span class="string">"MyApp"</span>);</span><br><span class="line">        c.getDeclaredMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;)</span><br><span class="line">                .invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;args&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleLoader</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException</span>&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> ClassPool();</span><br><span class="line">        pool.insertClassPath(<span class="string">"./test-classes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CtClass cc = pool.get(name);</span><br><span class="line">            <span class="keyword">byte</span>[] b = cc.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CannotCompileException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类MyApp是一个应用程序入口。执行该程序， 首选要先将类放在./class目录下，该目录不是类搜索路径中的目录。否则，MyApp.class将会被默认的系统类加载器加载，该加载器是SamplerLoader的父加载器。将指定的路径./class在构造方法中通过insertClassPath()方法加入到搜索路径中。你可以指定其他路径名字替代./class。 然后执行以下命令： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% java SampleLoader</span><br></pre></td></tr></table></figure>
<p>类加载器加载类MyApp（./class/MyApp.class）并且调用MyApp.main()方法，将命令行参数传给该方法。 </p>
<h3 id="3-5-修改系统类"><a href="#3-5-修改系统类" class="headerlink" title="3.5 修改系统类"></a>3.5 修改系统类</h3><p>系统类如java.lang.String不能被其他类加载器加载，除了系统类加载器之外。因此， SampleLoader或者javassist.Loader，如上所示， 不能在加载时修改系统类。 </p>
<p>如果你的应用需要做到这一点，系统类必须被静态修改。比如，以下程序增加一个新的属性hiddenValue到java.lang.String类中： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">CtClass cc = pool.get(<span class="string">"java.lang.String"</span>); </span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"hiddenValue"</span>, cc); </span><br><span class="line">f.setModifiers(Modifier.PUBLIC); </span><br><span class="line">cc.addField(f); </span><br><span class="line">cc.writeFile(<span class="string">"."</span>);</span><br></pre></td></tr></table></figure>
<p>这段程序产生一个类”./java/lang/Stirng.class”。运行这段程序MyApp，使用修改后的String类，需使用如下方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% java -Xbootclasspath/p:.  MyApp arg1 arg2 ...</span><br></pre></td></tr></table></figure>
<p>假设MyApp的定义如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Stirng.class.getField(<span class="string">"hiddenValue"</span>).getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果被修改的String类被正确加载， MyApp将打印hiddenValue。 </p>
<blockquote>
<p>注意：用该技术修改rt.jar的系统类的应用程序，不应该被部署，这违反了<code>Java 2 Runtime Environment binary code license</code></p>
</blockquote>
<h3 id="3-6-运行时重新加载类"><a href="#3-6-运行时重新加载类" class="headerlink" title="3.6 运行时重新加载类"></a>3.6 运行时重新加载类</h3><p>如果启动JVM启用了JPDA(Java平台调试架构-Java Platform Debugger Architechure)功能，一个类可以动态重新加载。在JVM加载一个类后，老版本的类定义将被卸载，新版本的类将被重新加载。因此，类定义可以在运行时动态修改。但是，新类定义必须兼容老的类。JVM不允许两个类版本的模型被改变。他们必须拥有相同的方法和属性集合。 </p>
<p>Javassist提供了方便的类在运行时重新加载类。更多信息，查看API文档， 关于javassist.tools.HotSwapper部分。 </p>
</div><div class="tags"><a href="/tags/javassist/">javassist</a><a href="/tags/bytecode/">bytecode</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/11/14/【译】javassist使用指南二/" class="next">【译】javassist使用指南二(ClassPool)</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#三、ClassLoader"><span class="toc-text">三、ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-CtClass类的toClass方法"><span class="toc-text">3.1 CtClass类的toClass方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Java中的类加载机制"><span class="toc-text">3.2 Java中的类加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-使用javassist-Loader"><span class="toc-text">3.3 使用javassist.Loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-编写一个类加载器"><span class="toc-text">3.4 编写一个类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-修改系统类"><span class="toc-text">3.5 修改系统类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-运行时重新加载类"><span class="toc-text">3.6 运行时重新加载类</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/【译】javassist使用指南三/">【译】javassist使用指南三(ClassLoader)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/14/【译】javassist使用指南二/">【译】javassist使用指南二(ClassPool)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/12/【译】javassist使用指南一/">【译】javassist使用指南一（前言、读写字节码）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/maven-shade-plugin/">maven-shade-plugin介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/02/java-agent/">Java Agent</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/10/hello-world-embedding-jetty-servlet/">org.demo.Hello World!——内嵌Jetty支持Servlet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/27/hello-world-embedding-jetty/">org.demo.Hello World！——内嵌Jetty</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java-thread-create/">Java多线程的实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/create-jdk-docker-image/">Dockerfile构建jdk镜像和tomcat镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/23/centos7-install-zookeeper/">zookeeper安装：单机模式、伪集群模式、集群模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github-博客/">github 博客</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javassist/">javassist</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/org-demo-Hello-World系列/">org.demo.Hello World系列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/折腾过程/">折腾过程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/问题处理/">问题处理</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Instrument/" style="font-size: 15px;">Instrument</a> <a href="/tags/vagrant/" style="font-size: 15px;">vagrant</a> <a href="/tags/virtualbox/" style="font-size: 15px;">virtualbox</a> <a href="/tags/vagrant-box/" style="font-size: 15px;">vagrant box</a> <a href="/tags/jdk8/" style="font-size: 15px;">jdk8</a> <a href="/tags/eclipse快捷键/" style="font-size: 15px;">eclipse快捷键</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/jdk镜像/" style="font-size: 15px;">jdk镜像</a> <a href="/tags/tomcat镜像/" style="font-size: 15px;">tomcat镜像</a> <a href="/tags/docker镜像/" style="font-size: 15px;">docker镜像</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/eclipse调试/" style="font-size: 15px;">eclipse调试</a> <a href="/tags/org-demo-Hello-World/" style="font-size: 15px;">org.demo.Hello World</a> <a href="/tags/Jetty/" style="font-size: 15px;">Jetty</a> <a href="/tags/内嵌Jetty/" style="font-size: 15px;">内嵌Jetty</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/jsp/" style="font-size: 15px;">jsp</a> <a href="/tags/Java-Agent/" style="font-size: 15px;">Java Agent</a> <a href="/tags/centos7/" style="font-size: 15px;">centos7</a> <a href="/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/tags/java多线程/" style="font-size: 15px;">java多线程</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/FutureTask/" style="font-size: 15px;">FutureTask</a> <a href="/tags/Runnable/" style="font-size: 15px;">Runnable</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/ssh/" style="font-size: 15px;">ssh</a> <a href="/tags/ssh-key/" style="font-size: 15px;">ssh key</a> <a href="/tags/github-pages/" style="font-size: 15px;">github pages</a> <a href="/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/tags/OOM/" style="font-size: 15px;">OOM</a> <a href="/tags/virtual-vm/" style="font-size: 15px;">virtual vm</a> <a href="/tags/MAT/" style="font-size: 15px;">MAT</a> <a href="/tags/pinpoint/" style="font-size: 15px;">pinpoint</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/javassist/" style="font-size: 15px;">javassist</a> <a href="/tags/bytecode/" style="font-size: 15px;">bytecode</a> <a href="/tags/maven-shade-plugin/" style="font-size: 15px;">maven-shade-plugin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">zheng run.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>